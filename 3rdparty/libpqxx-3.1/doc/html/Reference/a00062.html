<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libpqxx: pqxx::pipeline Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00171.html">pqxx</a>::<a class="el" href="a00062.html">pipeline</a>
  </div>
</div>
<div class="contents">
<h1>pqxx::pipeline Class Reference</h1><!-- doxytag: class="pqxx::pipeline" --><!-- doxytag: inherits="pqxx::internal::transactionfocus" -->Processes several queries in FIFO manner, optimized for high throughput.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00237.html">pipeline.hxx</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for pqxx::pipeline:</div>
<div class="dynsection">
<p><center><img src="a00592.png" border="0" usemap="#a00593" alt="Inheritance graph"></center>
<map name="a00593">
<area shape="rect" href="a00106.html" title="pqxx::internal::transactionfocus" alt="" coords="5,84,227,111"><area shape="rect" href="a00053.html" title="pqxx::internal::namedclass" alt="" coords="20,7,212,34"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00594.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">query_id</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#41ad44c7f13ad198db938c84e25473a9">pipeline</a> (<a class="el" href="a00105.html">transaction_base</a> &amp;, const std::string &amp;Name=std::string())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#b265dd1ed168022f92a207dd62bad5d1">~pipeline</a> ()  throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#839abbb0e60ac35e941a632027b4f917">insert</a> (const std::string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add query to the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a>.  <a href="#839abbb0e60ac35e941a632027b4f917"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#7808218284e98bb5dffaf110defd1b33">complete</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for all ongoing or pending operations to complete.  <a href="#7808218284e98bb5dffaf110defd1b33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#33a890c64efc37d76f3c649f145ff950">flush</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forget all ongoing or pending operations and retrieved results.  <a href="#33a890c64efc37d76f3c649f145ff950"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#b375b0b4e02c7f1a48602c4186fbbbd7">cancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel ongoing query, if any.  <a href="#b375b0b4e02c7f1a48602c4186fbbbd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#3d89c57d7619430a3847595d8fb902bc">is_finished</a> (<a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is <a class="el" href="a00076.html" title="Query or command result set.">result</a> for given query available?  <a href="#3d89c57d7619430a3847595d8fb902bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00076.html">result</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#19c508710d0025993e41512f23de56be">retrieve</a> (<a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">query_id</a> qid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve <a class="el" href="a00076.html" title="Query or command result set.">result</a> for given query.  <a href="#19c508710d0025993e41512f23de56be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>, <a class="el" href="a00076.html">result</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#9edc9c6e50f25790c3707495ab9779dd">retrieve</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve oldest unretrieved <a class="el" href="a00076.html" title="Query or command result set.">result</a> (possibly wait for one).  <a href="#9edc9c6e50f25790c3707495ab9779dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#5f5fe658349dcd9aed9c19faccf23ea4">empty</a> () const   throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#f94a53d0eecb7485cb135155f912ce8e">retain</a> (int retain_max=2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set maximum number of queries to retain before issuing them to the backend.  <a href="#f94a53d0eecb7485cb135155f912ce8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html#153e247a4f449ce8069379c4567738e9">resume</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume retained query emission (harmless when not needed).  <a href="#153e247a4f449ce8069379c4567738e9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>getquery</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Query</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Processes several queries in FIFO manner, optimized for high throughput. 
<p>
Use a <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> if you want to execute queries without always sitting still while they execute. Result retrieval is decoupled from execution request; queries "go in at the front" and results "come out the back." Actually results may be retrieved in any order, if you want.<p>
Feel free to pump as many queries into the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> as possible, even if they were generated after looking at a <a class="el" href="a00076.html" title="Query or command result set.">result</a> from the same <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a>. To get the best possible throughput, try to make insertion of queries run as far ahead of results retrieval as possible; issue each query as early as possible and retrieve their results as late as possible, so the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> has as many ongoing queries as possible at any given time. In other words, keep it busy!<p>
One warning: if any of the queries you insert leads to a syntactic error, the error may be returned as if it were generated by an older query. Future versions may try to work around this if working in a <a class="el" href="a00055.html">nontransaction</a>. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="b53d0c0294ef3c3c7147be2ab55bab0e"></a><!-- doxytag: member="pqxx::pipeline::query_id" ref="b53d0c0294ef3c3c7147be2ab55bab0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">pqxx::pipeline::query_id</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="41ad44c7f13ad198db938c84e25473a9"></a><!-- doxytag: member="pqxx::pipeline::pipeline" ref="41ad44c7f13ad198db938c84e25473a9" args="(transaction_base &amp;, const std::string &amp;Name=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pqxx::pipeline::pipeline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00105.html">transaction_base</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>Name</em> = <code>std&nbsp;::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b265dd1ed168022f92a207dd62bad5d1"></a><!-- doxytag: member="pqxx::pipeline::~pipeline" ref="b265dd1ed168022f92a207dd62bad5d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pqxx::pipeline::~pipeline           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="a00236.html#l00140">cancel()</a>, <a class="el" href="a00258.html#l00293">pqxx::transaction_base::conn()</a>, and <a class="el" href="a00258.html#l00068">pqxx::internal::transactionfocus::m_Trans</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="839abbb0e60ac35e941a632027b4f917"></a><!-- doxytag: member="pqxx::pipeline::insert" ref="839abbb0e60ac35e941a632027b4f917" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">pipeline::query_id</a> pqxx::pipeline::insert           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add query to the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a>. 
<p>
Queries are accumulated in the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> and sent to the backend in a concatenated format, separated by semicolons. The queries you insert must not use this construct themselves, or the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> will get hopelessly confused! <dl class="return" compact><dt><b>Returns:</b></dt><dd>Identifier for this query, unique only within this <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> </dd></dl>

<p>References <a class="el" href="a00236.html#l00031">pqxxassert</a>.</p>

</div>
</div><p>
<a class="anchor" name="7808218284e98bb5dffaf110defd1b33"></a><!-- doxytag: member="pqxx::pipeline::complete" ref="7808218284e98bb5dffaf110defd1b33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::complete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for all ongoing or pending operations to complete. 
<p>
Detaches from the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> when done. 
<p>References <a class="el" href="a00236.html#l00031">pqxxassert</a>.</p>

</div>
</div><p>
<a class="anchor" name="33a890c64efc37d76f3c649f145ff950"></a><!-- doxytag: member="pqxx::pipeline::flush" ref="33a890c64efc37d76f3c649f145ff950" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::flush           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forget all ongoing or pending operations and retrieved results. 
<p>
Queries already sent to the backend may still be completed, depending on implementation and timing.<p>
Any error state (unless caused by an <a class="el" href="a00186.html" title="Private namespace for libpqxx&#39;s internal use; do not access.">internal</a> error) will also be cleared. This is mostly useful in a <a class="el" href="a00055.html">nontransaction</a>, since a backend <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> is aborted automatically when an error occurs.<p>
Detaches from the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> when done. 
</div>
</div><p>
<a class="anchor" name="b375b0b4e02c7f1a48602c4186fbbbd7"></a><!-- doxytag: member="pqxx::pipeline::cancel" ref="b375b0b4e02c7f1a48602c4186fbbbd7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::cancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel ongoing query, if any. 
<p>
May cancel any or all of the queries that have been inserted at this point whose results have not yet been retrieved. If the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> lives in a backend <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>, that <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> may be left in a nonfunctional state in which it can only be aborted.<p>
Therefore, either use this function in a <a class="el" href="a00055.html">nontransaction</a>, or abort the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> after calling it. 
<p>References <a class="el" href="a00258.html#l00293">pqxx::transaction_base::conn()</a>, and <a class="el" href="a00258.html#l00068">pqxx::internal::transactionfocus::m_Trans</a>.</p>

<p>Referenced by <a class="el" href="a00236.html#l00057">~pipeline()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3d89c57d7619430a3847595d8fb902bc"></a><!-- doxytag: member="pqxx::pipeline::is_finished" ref="3d89c57d7619430a3847595d8fb902bc" args="(query_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::pipeline::is_finished           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">pipeline::query_id</a>&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is <a class="el" href="a00076.html" title="Query or command result set.">result</a> for given query available? 
<p>

<p>References <a class="el" href="a00241.html#l01012">pqxx::to_string()</a>.</p>

</div>
</div><p>
<a class="anchor" name="19c508710d0025993e41512f23de56be"></a><!-- doxytag: member="pqxx::pipeline::retrieve" ref="19c508710d0025993e41512f23de56be" args="(query_id qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00076.html">result</a> pqxx::pipeline::retrieve           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>&nbsp;</td>
          <td class="paramname"> <em>qid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve <a class="el" href="a00076.html" title="Query or command result set.">result</a> for given query. 
<p>
If the query failed for whatever reason, this will throw an exception. The function will block if the query has not finished yet. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>If results are retrieved out-of-order, i.e. in a different order than the one in which their queries were inserted, errors may "propagate" to subsequent queries. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9edc9c6e50f25790c3707495ab9779dd"></a><!-- doxytag: member="pqxx::pipeline::retrieve" ref="9edc9c6e50f25790c3707495ab9779dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="a00062.html#b53d0c0294ef3c3c7147be2ab55bab0e">pipeline::query_id</a>, <a class="el" href="a00076.html">result</a> &gt; pqxx::pipeline::retrieve           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve oldest unretrieved <a class="el" href="a00076.html" title="Query or command result set.">result</a> (possibly wait for one). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The query's identifier and its <a class="el" href="a00076.html" title="Query or command result set.">result</a> set </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f5fe658349dcd9aed9c19faccf23ea4"></a><!-- doxytag: member="pqxx::pipeline::empty" ref="5f5fe658349dcd9aed9c19faccf23ea4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::pipeline::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f94a53d0eecb7485cb135155f912ce8e"></a><!-- doxytag: member="pqxx::pipeline::retain" ref="f94a53d0eecb7485cb135155f912ce8e" args="(int retain_max=2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::pipeline::retain           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>retain_max</em> = <code>2</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set maximum number of queries to retain before issuing them to the backend. 
<p>
The <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> will perform better if multiple queries are issued at once, but retaining queries until the results are needed (as opposed to issuing them to the backend immediately) may negate any performance benefits the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> can offer.<p>
Recommended practice is to set this value no higher than the number of queries you intend to insert at a time. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>retain_max</em>&nbsp;</td><td>A nonnegative "retention capacity;" passing zero will cause queries to be issued immediately </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Old retention capacity </dd></dl>

<p>References <a class="el" href="a00236.html#l00184">resume()</a>, and <a class="el" href="a00241.html#l01012">pqxx::to_string()</a>.</p>

</div>
</div><p>
<a class="anchor" name="153e247a4f449ce8069379c4567738e9"></a><!-- doxytag: member="pqxx::pipeline::resume" ref="153e247a4f449ce8069379c4567738e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::resume           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resume retained query emission (harmless when not needed). 
<p>

<p>Referenced by <a class="el" href="a00236.html#l00169">retain()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00237.html">pipeline.hxx</a><li><a class="el" href="a00146.html">pipeline.cxx</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 15 18:22:52 2010 for libpqxx by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
