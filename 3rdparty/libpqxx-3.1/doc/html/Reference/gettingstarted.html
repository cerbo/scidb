<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libpqxx: Getting started</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="gettingstarted">Getting started </a></h1>The most basic three types in libpqxx are the connection (which inherits its API from <a class="el" href="a00020.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> and its setup behaviour from <a class="el" href="a00021.html">pqxx::connectionpolicy</a>), the transaction (derived from <a class="el" href="a00105.html">pqxx::transaction_base</a>), and the result (<a class="el" href="a00076.html" title="Query or command result set.">pqxx::result</a>).<p>
They fit together as follows: <ul>
<li>You connect to the database by creating a connection object (see <a class="el" href="a00197.html">Connection classes</a>). The connection type you'll usually want is <a class="el" href="a00197.html#g26edb910e4563d1115e22c627914e98b" title="The &quot;standard&quot; connection type: connect to database right now.">pqxx::connection</a>. </li>
<li>You create a transaction object (see <a class="el" href="a00199.html">Transaction classes</a>) operating on that connection. You'll usually want the <a class="el" href="a00199.html#g82685329d6fd91f5ab30772d266fe5f0" title="Bog-standard, default transaction type.">pqxx::work</a> variety. If you don't want transactional behaviour, use <a class="el" href="a00055.html">pqxx::nontransaction</a>. Once you're done you call the transaction's <code>commit</code> function to make its work final. If you don't call this, the work will be rolled back when the transaction object is destroyed. </li>
<li>Until then, use the transaction's <code>exec</code> function to execute queries, which you pass in as simple strings. </li>
<li>The function returns a <a class="el" href="a00076.html" title="Query or command result set.">pqxx::result</a> object, which acts as a standard container of rows. Each row in itself acts as a container of fields. You can use array indexing and/or iterators to access either. </li>
<li>The field's data is stored as a text string. You can read it as such using its <code>c_str()</code> function, or convert it to other types using its <code>as()</code> and <code>to()</code> member functions. These are templated on the destination type: <code>myfield.as&lt;int&gt;()</code>; or <code>myfield.to(myint)</code>; </li>
<li>After you've closed the transaction, the connection is free to run a next transaction.</li>
</ul>
Here's a very basic example. It connects to the default database (you'll need to have one set up), queries it for a very simple result, converts it to an <code>int</code>, and prints it out. It also contains some basic error handling.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;pqxx/pqxx&gt;</span>

 <span class="keywordtype">int</span> main()
 {
   <span class="keywordflow">try</span>
   {
     <a class="code" href="a00003.html" title="The ultimate template that defines a connection type.">pqxx::connection</a> c;
     <a class="code" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">pqxx::work</a> w(c);
     <a class="code" href="a00076.html" title="Query or command result set.">pqxx::result</a> r = w.exec(<span class="stringliteral">"SELECT 1"</span>);
     w.commit();

     std::cout &lt;&lt; r[0][0].as&lt;<span class="keywordtype">int</span>&gt;() &lt;&lt; std::endl;
   }
   <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;e)
   {
     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
   }
 }
</pre></div><p>
This prints the number 1. Notice that you can keep the result object around after the transaction (or even the connection) has been closed.<p>
Here's a slightly more complicated example. It takes an argument from the command line and retrieves a string with that value. The interesting part is that it uses the escaping-and-quoting function <code>quote()</code> to embed this string value in SQL safely. It also reads the result field's value as a plain C-style string using its <code>c_str()</code> function.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;pqxx/pqxx&gt;</span>

 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
 {
   <span class="keywordflow">if</span> (!argv[1])
   {
     std::cerr &lt;&lt; <span class="stringliteral">"Give me a string!"</span> &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
   }
   <span class="keywordflow">try</span>
   {
     <a class="code" href="a00003.html" title="The ultimate template that defines a connection type.">pqxx::connection</a> c;
     <a class="code" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">pqxx::work</a> w(c);
     <a class="code" href="a00076.html" title="Query or command result set.">pqxx::result</a> r = w.exec(<span class="stringliteral">"SELECT "</span> + w.quote(argv[1]));
     w.commit();

     std::cout &lt;&lt; r[0][0].c_str() &lt;&lt; std::endl;
   }
   <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception &amp;e)
   {
     std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 1;
   }
 }
</pre></div><p>
You can find more about converting field values to native types, or converting values to strings for use with libpqxx, under <a class="el" href="a00194.html">String conversion</a>. More about getting to the tuples and fields of a result is under <a class="el" href="accessingresults.html">Accessing results and result rows</a>.<p>
If you want to handle exceptions thrown by libpqxx in more detail, for example to print the SQL contents of a query that failed, see <a class="el" href="a00200.html">Exception classes</a>. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 15 18:22:46 2010 for libpqxx by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
