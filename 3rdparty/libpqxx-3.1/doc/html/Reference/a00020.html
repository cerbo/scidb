<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libpqxx: pqxx::connection_base Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00171.html">pqxx</a>::<a class="el" href="a00020.html">connection_base</a>
  </div>
</div>
<div class="contents">
<h1>pqxx::connection_base Class Reference</h1><!-- doxytag: class="pqxx::connection_base" --><a class="el" href="a00020.html" title="connection_base abstract base class; represents a connection to a database.">connection_base</a> abstract base class; represents a connection to a database.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00219.html">connection_base.hxx</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for pqxx::connection_base:</div>
<div class="dynsection">
<p><center><img src="a00454.png" border="0" usemap="#a00455" alt="Inheritance graph"></center>
<map name="a00455">
<area shape="rect" href="a00003.html" title="The ultimate template that defines a connection type." alt="" coords="5,84,312,110"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="a00456.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Capabilities</h2></td></tr>
<tr><td colspan="2">Some functionality is only available in certain versions of the backend, or only when speaking certain versions of the communications protocol that connects us to the backend. This includes clauses for SQL statements that were not accepted in older database versions, but are required in newer versions to get the same behaviour. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71">capability</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71f5a4754aea608aaf5fca6caa51c44ce0">cap_prepared_statements</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71ba8a02f6bb5d2304bfbf2110c6cd791a">cap_create_table_with_oids</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71973dc9e4f56818f82b86fb13a5bbc405">cap_nested_transactions</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee718034abdbcd193f25d9d93cf79156e1fc">cap_cursor_scroll</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71d97556afc36aff4a62c61b67437c20c4">cap_cursor_with_hold</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee718ab47c10b60d6bd6664f6e88f300edcb">cap_cursor_update</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee7186380c8c083847ba3d16764784f5914f">cap_cursor_fetch_0</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee711f2b785abe834490c33dc4cf19c932d2">cap_table_column</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee7101e68a67b6a3c92ce9b0c92fa73e90b2">cap_read_only_transactions</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71befe533e379346c7b9644406c613eb02">cap_statement_varargs</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee716b019128f2fdcfa9d316042342846e2f">cap_prepare_unnamed_statement</a>, 
<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71366c98bc3385ecfb39496bf7240e5973">cap_parameterized_statements</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee714a873c5d7e7fb0a9022cdd110181a7de">cap_end</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Session capabilities.  <a href="a00020.html#306a884246abc1051bab4fb06393ee71">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#efdde864e05f88e84d748236b93659e7">supports</a> (<a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71">capability</a> c) const   throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this connection seem to support the given capability?  <a href="#efdde864e05f88e84d748236b93659e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#b63e45ad783d8adb8d4a9f03e03ef6ef">protocol_version</a> () const   throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What version of the PostgreSQL protocol is this connection using?  <a href="#b63e45ad783d8adb8d4a9f03e03ef6ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cdd295f691812773133147530aa6ff21">server_version</a> () const   throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What version of the PostgreSQL server are we connected to?  <a href="#cdd295f691812773133147530aa6ff21"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#9bd21013745b4454e248e637cdae1287">disconnect</a> ()  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicitly close connection.  <a href="#9bd21013745b4454e248e637cdae1287"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#36a26cf7e13f612749d49faf4f1654f8">is_open</a> () const   throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this connection open at the moment?  <a href="#36a26cf7e13f612749d49faf4f1654f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f53d2c135aa27cdb1a66ff550a26e555">trace</a> (FILE *)  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable tracing to a given output stream, or NULL to disable.  <a href="#f53d2c135aa27cdb1a66ff550a26e555"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#04895c06c5ae1d8b0863a32a28beff51">set_client_encoding</a> (const std::string &amp;Encoding)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set client-side character encoding.  <a href="#04895c06c5ae1d8b0863a32a28beff51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#120b9e03dcaa9b0c3ef7026afa64d954">set_variable</a> (const std::string &amp;Var, const std::string &amp;Value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set session variable.  <a href="#120b9e03dcaa9b0c3ef7026afa64d954"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#908a2ffdf56d8259492e9f3894e24f65">get_variable</a> (const std::string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read session variable.  <a href="#908a2ffdf56d8259492e9f3894e24f65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#4963aaba6da521d480c21c7ec01835cf">adorn_name</a> (const std::string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suffix unique number to name to make it unique within session context.  <a href="#4963aaba6da521d480c21c7ec01835cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#g8978ff727c03a1aaaa3a9d3fd3268abf">esc</a> (const char str[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape string for use as SQL string literal on this connection.  <a href="a00196.html#g8978ff727c03a1aaaa3a9d3fd3268abf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#ge711f65dd793a70629f97a2e0e54d8db">esc</a> (const char str[], size_t maxlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape string for use as SQL string literal on this connection.  <a href="a00196.html#ge711f65dd793a70629f97a2e0e54d8db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#gca9ba750fd096cfd652a4323dab3a653">esc</a> (const std::string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape string for use as SQL string literal on this connection.  <a href="a00196.html#gca9ba750fd096cfd652a4323dab3a653"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#g6a8c83d3dcea7114a00c188fe6a92779">esc_raw</a> (const unsigned char str[], size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape binary string for use as SQL string literal on this connection.  <a href="a00196.html#g6a8c83d3dcea7114a00c188fe6a92779"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00196.html#g504d44b2b133a3d606d08c6b829680b2">quote</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represent object as SQL string, including quoting &amp; escaping.  <a href="a00196.html#g504d44b2b133a3d606d08c6b829680b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#9709e4738b1bfb1dba547381749908cb">cancel_query</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to cancel the ongoing query, if any.  <a href="#9709e4738b1bfb1dba547381749908cb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Activation</div></td></tr>
<tr><td colspan="2"><div class="groupText">Connections can be temporarily deactivated, or they can break because of overly impatient firewalls dropping TCP connections. Where possible, libpqxx will try to re-activate these when resume using them, or you can wake them up explicitly. You probably won't need this feature, but you should be aware of it. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#1aa330287775aa1ff83f94714f772673">activate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicitly activate deferred or deactivated connection.  <a href="#1aa330287775aa1ff83f94714f772673"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#10b275082e18dbcb177a8871f92c7523">deactivate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicitly deactivate connection.  <a href="#10b275082e18dbcb177a8871f92c7523"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#edf7ac72658efa92e702a06b1964747a">inhibit_reactivation</a> (bool inhibit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disallow (or permit) connection recovery.  <a href="#edf7ac72658efa92e702a06b1964747a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#335ca1d83e65a9e57b907c431c3afbe1">simulate_failure</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the connection fail.  <a href="#335ca1d83e65a9e57b907c431c3afbe1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Error/warning output</div></td></tr>
<tr><td colspan="2"><div class="groupText">Whenever the database has a warning or error to report, it will call a <em>noticer</em> to process the associated message. The default noticer sends the text of the message to standard error output, but you may choose to select a different noticer for the connection. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::auto_ptr&lt; <a class="el" href="a00057.html">noticer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#c6b5f32ac91993b37531e96c2d14b18e">set_noticer</a> (std::auto_ptr&lt; <a class="el" href="a00057.html">noticer</a> &gt; N)  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set handler for postgresql errors or warning messages.  <a href="#c6b5f32ac91993b37531e96c2d14b18e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00057.html">noticer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#edf4e61e94ea58058e4bc592d98f8dc2">get_noticer</a> () const   throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#140578ed1e1c65c61deb0407ff25959f">process_notice</a> (const char[])  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke notice processor function. The message should end in newline.  <a href="#140578ed1e1c65c61deb0407ff25959f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#9d64420154827b3572dcdb955a93bfff">process_notice</a> (const std::string &amp;)  throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke notice processor function. Newline at end is recommended.  <a href="#9d64420154827b3572dcdb955a93bfff"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Connection properties</div></td></tr>
<tr><td colspan="2"><div class="groupText">These are probably not of great interest, since most are derived from information supplied by the client program itself, but they are included for completeness. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#043e536c1923594c246f2ca8db31dffa">dbname</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of database we're connected to, if any.  <a href="#043e536c1923594c246f2ca8db31dffa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#e02522000400fc2782e892ac0387d85b">username</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Database user ID we're connected under, if any.  <a href="#e02522000400fc2782e892ac0387d85b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#38dde9befa350a07a5ac093d13ee64e2">hostname</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Address of server, or NULL if none specified (i.e. default or local).  <a href="#38dde9befa350a07a5ac093d13ee64e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#826750f0f13ede4ac4e6ca8a84711b53">port</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Server port number we're connected to.  <a href="#826750f0f13ede4ac4e6ca8a84711b53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#7179e32df28bd4bc81b85d99b36ad791">backendpid</a> () const   throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process ID for backend process.  <a href="#7179e32df28bd4bc81b85d99b36ad791"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#8ac078b1077fbe19ee1d713bb6b71e8f">sock</a> () const   throw ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket currently used for connection, or -1 for none. Use with care!  <a href="#8ac078b1077fbe19ee1d713bb6b71e8f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Notifications and Listeners</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a839a066c0289a12f664e29c9dbafd38">get_notifs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for pending notifications and take appropriate action.  <a href="#a839a066c0289a12f664e29c9dbafd38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#b5c24029bda3198d826d24757e49c746">await_notification</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a notification to come in.  <a href="#b5c24029bda3198d826d24757e49c746"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a9e66faad88a94857c0749b9bbc5d352">await_notification</a> (long seconds, long microseconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a notification to come in, or for given timeout to pass.  <a href="#a9e66faad88a94857c0749b9bbc5d352"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Prepared statements</div></td></tr>
<tr><td colspan="2"><div class="groupText">PostgreSQL supports prepared SQL statements, i.e. statements that can be registered under a client-provided name, optimized once by the backend, and executed any number of times under the given name.<p>
Prepared statement definitions are not sensitive to transaction boundaries; a statement defined inside a transaction will remain defined outside that transaction, even if the transaction itself is subsequently aborted. Once a statement has been prepared, only closing the connection or explicitly "unpreparing" it can make it go away.<p>
Use the transaction classes' <code>prepared()</code>.exec() function to execute a prepared statement. Use <code>prepared()</code>.exists() to find out whether a statement has been prepared under a given name.<p>
A special case is the nameless prepared statement. You may prepare a statement without a name. The unnamed statement can be redefined at any time, without un-preparing it first.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Prepared statements are not necessarily defined on the backend right away; libpqxx generally does that lazily. This means that you can prepare statements before the connection is fully established, and that it's relatively cheap to pre-prepare lots of statements that you may or may not use during the session. On the other hand, it also means that errors in a prepared statement may not show up until you first try to invoke it. Such an error may then break the transaction it occurs in.<p>
Never try to prepare, execute, or unprepare a prepared statement manually using direct SQL queries. Always use the functions provided by libpqxx. </dd></dl>
<br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00026.html">prepare::declaration</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#d2b9e50c9ebfab7c86a091cd939e1e6c">prepare</a> (const std::string &amp;name, const std::string &amp;definition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a prepared statement.  <a href="#d2b9e50c9ebfab7c86a091cd939e1e6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00026.html">prepare::declaration</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f2dcc39b88897fe2bc3c5742edd43645">prepare</a> (const std::string &amp;definition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a nameless prepared statement.  <a href="#f2dcc39b88897fe2bc3c5742edd43645"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#30ec51634479614b45106532e87e5dc7">unprepare</a> (const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drop prepared statement.  <a href="#30ec51634479614b45106532e87e5dc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#32efdc645566975851bfc7d6b82d214c">prepare_now</a> (const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request that prepared statement be registered with the server.  <a href="#32efdc645566975851bfc7d6b82d214c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Transactor framework</div></td></tr>
<tr><td colspan="2"><div class="groupText">See the transactor class template for more about transactors. To use the transactor framework, encapsulate your transaction code in a class derived from an instantiation of the <a class="el" href="a00107.html">pqxx::transactor</a> template. Then, to execute it, create an object of your transactor class and pass it to one of the perform() functions here.<p>
The perform() functions may create and execute several copies of the transactor before succeeding or ultimately giving up. If there is any doubt over whether execution succeeded (this can happen if the connection to the server is lost just before the backend can confirm success), it is no longer retried and an in_doubt_error is thrown.<p>
Take care: no member functions will ever be invoked on the transactor object you pass into perform(). The object you pass in only serves as a "prototype" for the job to be done. The perform() function will copy-construct transactors from the original you passed in, executing the copies only. The original object remains "clean" in its original state. <br><br></div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename TRANSACTOR&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00020.html#53881917fd565daf7e66496fa74f397d">perform</a> (const TRANSACTOR &amp;T, int Attempts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> defined by a transactor-based object.  <a href="#53881917fd565daf7e66496fa74f397d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename TRANSACTOR&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00020.html#858d1cb7c11c365faf203935a48c5f1b">perform</a> (const TRANSACTOR &amp;T)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> defined by a transactor-based object.  <a href="#858d1cb7c11c365faf203935a48c5f1b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#33700cc6d830d28c3dbd48eb9b7276ab">connection_base</a> (<a class="el" href="a00021.html">connectionpolicy</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#1d1c129c2c5797a82f251ee9dabec77e">init</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f02016af0233bed748eb1ddab9685131">close</a> ()  throw ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f860fe4c418cfa4f573f34d73327d111">wait_read</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#b8c7dd5e54493e18d5900dd70012d062">wait_read</a> (long seconds, long microseconds) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#cfb8d53e6f105db280cd5d977c005bea">wait_write</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#1407974cc9c548bee6d31834625c3d45">internal::gate::connection_prepare_declaration</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#c2eff365ba0aa25ebbf5f903ac3c7a54">internal::gate::connection_prepare_invocation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#3c60c76e32687adce1e8c0dba0919773">internal::gate::connection_transaction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#b15ff67d81467d271dc713b2584f1328">internal::gate::connection_largeobject</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#518f718405d80def662f248b427f0e60">internal::gate::connection_notify_listener</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#3b9c5dc16f04600aa5415e06f6ff8fa6">internal::gate::connection_pipeline</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#f3dfec559fe2305e57aba653abe4c8ad">internal::gate::connection_dbtransaction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#84c1a28176815ab9103c7febec450755">internal::gate::connection_sql_cursor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#2247d8690958f634898bbf014a7d418c">internal::gate::connection_reactivation_avoidance_exemption</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#0e64dc314f291c6f81a948c59d94aa8a">internal::gate::connection_parameterized_invocation</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="a00020.html" title="connection_base abstract base class; represents a connection to a database.">connection_base</a> abstract base class; represents a connection to a database. 
<p>
This is the first class to look at when you wish to work with a database through libpqxx. Depending on the implementing concrete child class, a connection can be automatically opened when it is constructed, or when it is first used, or somewhere inbetween. The connection is automatically closed upon destruction (if it hasn't been closed already).<p>
To query or manipulate the database once connected, use one of the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> classes (see <a class="el" href="a00168.html">pqxx/transaction_base.hxx</a>) or preferably the <a class="el" href="a00107.html">transactor</a> framework (see <a class="el" href="a00169.html">pqxx/transactor.hxx</a>).<p>
If a network connection to the database server fails, the connection will be restored automatically (although any <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> going on at the time will have to be aborted). This also means that any information set in previous transactions that is not stored in the database, such as temp tables or connection-local variables defined with PostgreSQL's SET command, will be lost. Whenever you create such state, either keept it local to one <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>, where possible, or inhibit automatic reactivation of the connection using the <a class="el" href="a00020.html#edf7ac72658efa92e702a06b1964747a" title="Disallow (or permit) connection recovery.">inhibit_reactivation()</a> method.<p>
When a connection breaks, you will typically get a <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> exception. This can happen at almost any point, and the details may depend on which connection class (all derived from this one) you use.<p>
As a general rule, always avoid raw queries if libpqxx offers a dedicated function for the same purpose. There may be hidden logic to hide certain complications from you, such as reinstating session variables when a broken or disabled connection is reactivated.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>On Unix-like systems, including GNU and BSD systems, your program may receive the SIGPIPE signal when the connection to the backend breaks. By default this signal will abort your program. Use "signal(SIGPIPE, SIG_IGN)" if you want your program to continue running after a connection fails. </dd></dl>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="306a884246abc1051bab4fb06393ee71"></a><!-- doxytag: member="pqxx::connection_base::capability" ref="306a884246abc1051bab4fb06393ee71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71">pqxx::connection_base::capability</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Session capabilities. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee71f5a4754aea608aaf5fca6caa51c44ce0"></a><!-- doxytag: member="cap_prepared_statements" ref="306a884246abc1051bab4fb06393ee71f5a4754aea608aaf5fca6caa51c44ce0" args="" -->cap_prepared_statements</em>&nbsp;</td><td>
Does the backend support prepared statements? (If not, we emulate them). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee71ba8a02f6bb5d2304bfbf2110c6cd791a"></a><!-- doxytag: member="cap_create_table_with_oids" ref="306a884246abc1051bab4fb06393ee71ba8a02f6bb5d2304bfbf2110c6cd791a" args="" -->cap_create_table_with_oids</em>&nbsp;</td><td>
Can we specify WITH OIDS with CREATE TABLE? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee71973dc9e4f56818f82b86fb13a5bbc405"></a><!-- doxytag: member="cap_nested_transactions" ref="306a884246abc1051bab4fb06393ee71973dc9e4f56818f82b86fb13a5bbc405" args="" -->cap_nested_transactions</em>&nbsp;</td><td>
Can transactions be nested in other transactions? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee718034abdbcd193f25d9d93cf79156e1fc"></a><!-- doxytag: member="cap_cursor_scroll" ref="306a884246abc1051bab4fb06393ee718034abdbcd193f25d9d93cf79156e1fc" args="" -->cap_cursor_scroll</em>&nbsp;</td><td>
Can cursors be declared SCROLL? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee71d97556afc36aff4a62c61b67437c20c4"></a><!-- doxytag: member="cap_cursor_with_hold" ref="306a884246abc1051bab4fb06393ee71d97556afc36aff4a62c61b67437c20c4" args="" -->cap_cursor_with_hold</em>&nbsp;</td><td>
Can cursors be declared WITH HOLD? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee718ab47c10b60d6bd6664f6e88f300edcb"></a><!-- doxytag: member="cap_cursor_update" ref="306a884246abc1051bab4fb06393ee718ab47c10b60d6bd6664f6e88f300edcb" args="" -->cap_cursor_update</em>&nbsp;</td><td>
Can cursors be updateable? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee7186380c8c083847ba3d16764784f5914f"></a><!-- doxytag: member="cap_cursor_fetch_0" ref="306a884246abc1051bab4fb06393ee7186380c8c083847ba3d16764784f5914f" args="" -->cap_cursor_fetch_0</em>&nbsp;</td><td>
Can cursors fetch zero elements? (Used to trigger a "fetch all"). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee711f2b785abe834490c33dc4cf19c932d2"></a><!-- doxytag: member="cap_table_column" ref="306a884246abc1051bab4fb06393ee711f2b785abe834490c33dc4cf19c932d2" args="" -->cap_table_column</em>&nbsp;</td><td>
Can we ask what table column a <a class="el" href="a00076.html" title="Query or command result set.">result</a> column came from? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee7101e68a67b6a3c92ce9b0c92fa73e90b2"></a><!-- doxytag: member="cap_read_only_transactions" ref="306a884246abc1051bab4fb06393ee7101e68a67b6a3c92ce9b0c92fa73e90b2" args="" -->cap_read_only_transactions</em>&nbsp;</td><td>
Can transactions be READ ONLY? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee71befe533e379346c7b9644406c613eb02"></a><!-- doxytag: member="cap_statement_varargs" ref="306a884246abc1051bab4fb06393ee71befe533e379346c7b9644406c613eb02" args="" -->cap_statement_varargs</em>&nbsp;</td><td>
Do prepared statements support varargs? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee716b019128f2fdcfa9d316042342846e2f"></a><!-- doxytag: member="cap_prepare_unnamed_statement" ref="306a884246abc1051bab4fb06393ee716b019128f2fdcfa9d316042342846e2f" args="" -->cap_prepare_unnamed_statement</em>&nbsp;</td><td>
Is the unnamed prepared statement supported? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee71366c98bc3385ecfb39496bf7240e5973"></a><!-- doxytag: member="cap_parameterized_statements" ref="306a884246abc1051bab4fb06393ee71366c98bc3385ecfb39496bf7240e5973" args="" -->cap_parameterized_statements</em>&nbsp;</td><td>
Can this connection execute parameterized statements? </td></tr>
<tr><td valign="top"><em><a class="anchor" name="306a884246abc1051bab4fb06393ee714a873c5d7e7fb0a9022cdd110181a7de"></a><!-- doxytag: member="cap_end" ref="306a884246abc1051bab4fb06393ee714a873c5d7e7fb0a9022cdd110181a7de" args="" -->cap_end</em>&nbsp;</td><td>
Not a capability value; end-of-enumeration marker. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="33700cc6d830d28c3dbd48eb9b7276ab"></a><!-- doxytag: member="pqxx::connection_base::connection_base" ref="33700cc6d830d28c3dbd48eb9b7276ab" args="(connectionpolicy &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pqxx::connection_base::connection_base           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00021.html">connectionpolicy</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pol</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9bd21013745b4454e248e637cdae1287"></a><!-- doxytag: member="pqxx::connection_base::disconnect" ref="9bd21013745b4454e248e637cdae1287" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::disconnect           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly close connection. 
<p>

<p>References <a class="el" href="a00216.html#l00075">pqxx::connectionpolicy::do_disconnect()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l00182">activate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="36a26cf7e13f612749d49faf4f1654f8"></a><!-- doxytag: member="pqxx::connection_base::is_open" ref="36a26cf7e13f612749d49faf4f1654f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::connection_base::is_open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this connection open at the moment? 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This function is <b>not</b> needed in most code. Resist the temptation to check it after opening a connection; instead, rely on the <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> exception that will be thrown on connection <a class="el" href="a00032.html" title="Run-time failure encountered by libpqxx, similar to std::runtime_error.">failure</a>. </dd></dl>

<p>Referenced by <a class="el" href="a00218.html#l00182">activate()</a>, <a class="el" href="a00257.html#l00111">pqxx::transaction_base::commit()</a>, <a class="el" href="a00218.html#l00731">get_notifs()</a>, and <a class="el" href="a00218.html#l00265">set_variable()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1aa330287775aa1ff83f94714f772673"></a><!-- doxytag: member="pqxx::connection_base::activate" ref="1aa330287775aa1ff83f94714f772673" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::activate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly activate deferred or deactivated connection. 
<p>
Use of this method is entirely optional. Whenever a connection is used while in a deferred or deactivated state, it will transparently try to bring itself into an activated state. This function is best viewed as an explicit hint to the connection that "if you're not in an active state, now would be a good time to get into one." Whether a connection is currently in an active state or not makes no real difference to its functionality. There is also no particular need to match calls to <a class="el" href="a00020.html#1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection.">activate()</a> with calls to <a class="el" href="a00020.html#10b275082e18dbcb177a8871f92c7523" title="Explicitly deactivate connection.">deactivate()</a>. A good time to call <a class="el" href="a00020.html#1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection.">activate()</a> might be just before you first open a <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> on a lazy connection. 
<p>References <a class="el" href="a00218.html#l00462">disconnect()</a>, <a class="el" href="a00216.html#l00063">pqxx::connectionpolicy::do_completeconnect()</a>, <a class="el" href="a00216.html#l00057">pqxx::connectionpolicy::do_startconnect()</a>, <a class="el" href="a00219.html#l00063">pqxx::internal::reactivation_avoidance_counter::get()</a>, and <a class="el" href="a00218.html#l00471">is_open()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l01580">await_notification()</a>, <a class="el" href="a00218.html#l00785">dbname()</a>, <a class="el" href="a00218.html#l01404">esc()</a>, <a class="el" href="a00218.html#l01477">esc_raw()</a>, <a class="el" href="a00218.html#l00799">hostname()</a>, <a class="el" href="a00218.html#l00142">init()</a>, <a class="el" href="a00218.html#l00806">port()</a>, and <a class="el" href="a00218.html#l00792">username()</a>.</p>

</div>
</div><p>
<a class="anchor" name="10b275082e18dbcb177a8871f92c7523"></a><!-- doxytag: member="pqxx::connection_base::deactivate" ref="10b275082e18dbcb177a8871f92c7523" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::deactivate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly deactivate connection. 
<p>
Like its counterpart <a class="el" href="a00020.html#1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection.">activate()</a>, this method is entirely optional. Calling this function really only makes sense if you won't be using this connection for a while and want to reduce the number of open connections on the database server. There is no particular need to match or pair calls to <a class="el" href="a00020.html#10b275082e18dbcb177a8871f92c7523" title="Explicitly deactivate connection.">deactivate()</a> with calls to <a class="el" href="a00020.html#1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection.">activate()</a>, but calling <a class="el" href="a00020.html#10b275082e18dbcb177a8871f92c7523" title="Explicitly deactivate connection.">deactivate()</a> during a <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> is an error. 
<p>References <a class="el" href="a00216.html#l00075">pqxx::connectionpolicy::do_disconnect()</a>, <a class="el" href="a00219.html#l00063">pqxx::internal::reactivation_avoidance_counter::get()</a>, and <a class="el" href="a00218.html#l00514">process_notice()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l01513">pqxx::internal::reactivation_avoidance_exemption::~reactivation_avoidance_exemption()</a>.</p>

</div>
</div><p>
<a class="anchor" name="edf7ac72658efa92e702a06b1964747a"></a><!-- doxytag: member="pqxx::connection_base::inhibit_reactivation" ref="edf7ac72658efa92e702a06b1964747a" args="(bool inhibit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::inhibit_reactivation           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inhibit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disallow (or permit) connection recovery. 
<p>
A connection whose underlying socket is not currently connected to the server will normally (re-)establish communication with the server whenever needed, or when the client program requests it (although for reasons of integrity, never inside a <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>; but retrying the whole <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> may implicitly cause the connection to be restored). In normal use this is quite a convenient thing to have and presents a simple, safe, predictable interface.<p>
There is at least one situation where this feature is not desirable, however. Although most session state (prepared statements, session variables) is automatically restored to its working state upon connection reactivation, temporary tables and so-called WITH HOLD cursors (which can live outside transactions) are not.<p>
Cursors that live outside transactions are automatically handled, and the library will quietly ignore requests to deactivate or reactivate connections while they exist; it does not want to give you the illusion of being back in your <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> when in reality you just dropped a cursor. With temporary tables this is not so easy: there is no easy way for the library to detect their creation or track their lifetimes.<p>
So if your program uses temporary tables, and any part of this use happens outside of any database <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> (or spans multiple transactions), some of the work you have done on these tables may unexpectedly be undone if the connection is broken or deactivated while any of these tables exists, and then reactivated or implicitly restored before you are finished with it.<p>
If this describes any part of your program, guard it against unexpected reconnections by inhibiting reconnection at the beginning. And if you want to continue doing work on the connection afterwards that no longer requires the temp tables, you can permit it again to get the benefits of connection reactivation for the remainder of the program.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inhibit</em>&nbsp;</td><td>should reactivation be inhibited from here on?</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Some connection types (the lazy and asynchronous types) defer completion of the socket-level connection until it is actually needed by the client program. Inhibiting reactivation before this connection is really established will prevent these connection types from doing their work. For those connection types, if you are sure that reactivation needs to be inhibited before any query goes across the connection, <a class="el" href="a00020.html#1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection.">activate()</a> the connection first. This will ensure that definite activation happens before you inhibit it. </dd></dl>

<p>Referenced by <a class="el" href="a00218.html#l01162">close()</a>, and <a class="el" href="a00218.html#l00239">simulate_failure()</a>.</p>

</div>
</div><p>
<a class="anchor" name="335ca1d83e65a9e57b907c431c3afbe1"></a><!-- doxytag: member="pqxx::connection_base::simulate_failure" ref="335ca1d83e65a9e57b907c431c3afbe1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::simulate_failure           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make the connection fail. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Do not use this except for testing! Breaks the connection in some unspecified, horrible, dirty way to enable <a class="el" href="a00032.html" title="Run-time failure encountered by libpqxx, similar to std::runtime_error.">failure</a> testing.</dd></dl>
Do not use this in normal programs. This is only meant for testing. 
<p>References <a class="el" href="a00216.html#l00075">pqxx::connectionpolicy::do_disconnect()</a>, and <a class="el" href="a00219.html#l00270">inhibit_reactivation()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c6b5f32ac91993b37531e96c2d14b18e"></a><!-- doxytag: member="pqxx::connection_base::set_noticer" ref="c6b5f32ac91993b37531e96c2d14b18e" args="(std::auto_ptr&lt; noticer &gt; N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto_ptr&lt; <a class="el" href="a00057.html">pqxx::noticer</a> &gt; pqxx::connection_base::set_noticer           </td>
          <td>(</td>
          <td class="paramtype">std::auto_ptr&lt; <a class="el" href="a00057.html">noticer</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>N</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set handler for postgresql errors or warning messages. 
<p>
The use of auto_ptr implies ownership, so unless the returned value is copied to another auto_ptr, it will be deleted directly after the call. This may be important when running under Windows, where a DLL cannot free memory allocated by the main program. The auto_ptr will delete the object from your code context, rather than from inside the library.<p>
If a <a class="el" href="a00057.html" title="Base class for user-definable error/warning message processor.">noticer</a> exists when the <a class="el" href="a00020.html" title="connection_base abstract base class; represents a connection to a database.">connection_base</a> is destructed, it will also be deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>New message handler; must not be null or equal to the old one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Previous handler </dd></dl>

<p>Referenced by <a class="el" href="a00218.html#l01162">close()</a>, <a class="el" href="a00203.html#l00068">pqxx::basic_connection&lt; CONNECTPOLICY &gt;::~basic_connection()</a>, and <a class="el" href="a00219.html#l00984">pqxx::scoped_noticer::~scoped_noticer()</a>.</p>

</div>
</div><p>
<a class="anchor" name="edf4e61e94ea58058e4bc592d98f8dc2"></a><!-- doxytag: member="pqxx::connection_base::get_noticer" ref="edf4e61e94ea58058e4bc592d98f8dc2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00057.html">noticer</a>* pqxx::connection_base::get_noticer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="140578ed1e1c65c61deb0407ff25959f"></a><!-- doxytag: member="pqxx::connection_base::process_notice" ref="140578ed1e1c65c61deb0407ff25959f" args="(const char[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::process_notice           </td>
          <td>(</td>
          <td class="paramtype">const &nbsp;</td>
          <td class="paramname"> <em>char</em>[]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoke notice processor function. The message should end in newline. 
<p>

<p>Referenced by <a class="el" href="a00257.html#l00187">pqxx::transaction_base::abort()</a>, <a class="el" href="a00218.html#l01162">close()</a>, <a class="el" href="a00257.html#l00111">pqxx::transaction_base::commit()</a>, <a class="el" href="a00218.html#l00219">deactivate()</a>, <a class="el" href="a00257.html#l00348">pqxx::transaction_base::End()</a>, <a class="el" href="a00218.html#l00731">get_notifs()</a>, and <a class="el" href="a00257.html#l00079">pqxx::transaction_base::~transaction_base()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9d64420154827b3572dcdb955a93bfff"></a><!-- doxytag: member="pqxx::connection_base::process_notice" ref="9d64420154827b3572dcdb955a93bfff" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::process_notice           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoke notice processor function. Newline at end is recommended. 
<p>

</div>
</div><p>
<a class="anchor" name="f53d2c135aa27cdb1a66ff550a26e555"></a><!-- doxytag: member="pqxx::connection_base::trace" ref="f53d2c135aa27cdb1a66ff550a26e555" args="(FILE *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::trace           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>Out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable tracing to a given output stream, or NULL to disable. 
<p>

</div>
</div><p>
<a class="anchor" name="043e536c1923594c246f2ca8db31dffa"></a><!-- doxytag: member="pqxx::connection_base::dbname" ref="043e536c1923594c246f2ca8db31dffa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::dbname           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Name of database we're connected to, if any. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This activates the connection, which may fail with a <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> exception. </dd></dl>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e02522000400fc2782e892ac0387d85b"></a><!-- doxytag: member="pqxx::connection_base::username" ref="e02522000400fc2782e892ac0387d85b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::username           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Database user ID we're connected under, if any. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This activates the connection, which may fail with a <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> exception. </dd></dl>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="38dde9befa350a07a5ac093d13ee64e2"></a><!-- doxytag: member="pqxx::connection_base::hostname" ref="38dde9befa350a07a5ac093d13ee64e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::hostname           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Address of server, or NULL if none specified (i.e. default or local). 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This activates the connection, which may fail with a <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> exception. </dd></dl>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="826750f0f13ede4ac4e6ca8a84711b53"></a><!-- doxytag: member="pqxx::connection_base::port" ref="826750f0f13ede4ac4e6ca8a84711b53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::port           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Server port number we're connected to. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This activates the connection, which may fail with a <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> exception. </dd></dl>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7179e32df28bd4bc81b85d99b36ad791"></a><!-- doxytag: member="pqxx::connection_base::backendpid" ref="7179e32df28bd4bc81b85d99b36ad791" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::backendpid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process ID for backend process. 
<p>
Use with care: connections may be lost and automatically re-established without your knowledge, in which case this process ID may no longer be correct. You may, however, assume that this number remains constant and reliable within the span of a successful backend <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>. If the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> fails, which may be due to a lost connection, then this number will have become invalid at some point within the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Process identifier, or 0 if not currently connected. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ac078b1077fbe19ee1d713bb6b71e8f"></a><!-- doxytag: member="pqxx::connection_base::sock" ref="8ac078b1077fbe19ee1d713bb6b71e8f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::sock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket currently used for connection, or -1 for none. Use with care! 
<p>
Query the current socket number. This is intended for event loops based on functions such as select() or poll(), where multiple file descriptors are watched.<p>
Please try to stay away from this function. It is really only meant for event loops that need to wait on more than one file descriptor. If all you need is to block until a notification arrives, for instance, use <a class="el" href="a00020.html#b5c24029bda3198d826d24757e49c746" title="Wait for a notification to come in.">await_notification()</a>. If you want to issue queries and retrieve results in nonblocking fashion, check out the <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> class.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Don't store this value anywhere, and always be prepared for the possibility that there is no socket. The socket may change or even go away during any invocation of libpqxx code, no matter how trivial. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efdde864e05f88e84d748236b93659e7"></a><!-- doxytag: member="pqxx::connection_base::supports" ref="efdde864e05f88e84d748236b93659e7" args="(capability c) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::connection_base::supports           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#306a884246abc1051bab4fb06393ee71">capability</a>&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this connection seem to support the given capability? 
<p>
Don't try to be smart by caching this information anywhere. Obtaining it is quite fast (especially after the first time) and what's more, a capability may "suddenly" appear or disappear if the connection is broken or deactivated, and then restored. This may happen silently any time no backend <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> is active; if it turns out that the server was upgraded or restored from an older backup, or the new connection goes to a different backend, then the restored session may have different capabilities than were available previously.<p>
Some guesswork is involved in establishing the presence of any capability; try not to rely on this function being exactly right.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Make sure your connection is active before calling this function, or the answer will always be "no." In particular, if you are using this function on a newly-created lazyconnection, activate the connection first. </dd></dl>

<p>Referenced by <a class="el" href="a00218.html#l00839">prepare()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b63e45ad783d8adb8d4a9f03e03ef6ef"></a><!-- doxytag: member="pqxx::connection_base::protocol_version" ref="b63e45ad783d8adb8d4a9f03e03ef6ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::protocol_version           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
What version of the PostgreSQL protocol is this connection using? 
<p>
The answer can be 0 (when there is no connection, or the libpq version being used is too old to obtain the information); 2 for protocol 2.0; 3 for protocol 3.0; and possibly higher values as newer protocol versions are taken into use.<p>
If the connection is broken and restored, the restored connection could possibly a different server and protocol version. This would normally happen if the server is upgraded without shutting down the client program, for example.<p>
Requires libpq version from PostgreSQL 7.4 or better. 
</div>
</div><p>
<a class="anchor" name="cdd295f691812773133147530aa6ff21"></a><!-- doxytag: member="pqxx::connection_base::server_version" ref="cdd295f691812773133147530aa6ff21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::server_version           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
What version of the PostgreSQL server are we connected to? 
<p>
The <a class="el" href="a00076.html" title="Query or command result set.">result</a> is a bit complicated: each of the major, medium, and minor release numbers is written as a two-digit decimal number, and the three are then concatenated. Thus server version 7.4.2 will be returned as the decimal number 70402. If there is no connection to the server, of if the libpq version is too old to obtain the information, zero is returned.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>When writing version numbers in your code, don't add zero at the beginning! Numbers beginning with zero are interpreted as octal (base-8) in C++. Thus, 070402 is not the same as 70402, and 080000 is not a number at all because there is no digit "8" in octal notation. Use strictly decimal notation when it comes to these version numbers. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04895c06c5ae1d8b0863a32a28beff51"></a><!-- doxytag: member="pqxx::connection_base::set_client_encoding" ref="04895c06c5ae1d8b0863a32a28beff51" args="(const std::string &amp;Encoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::set_client_encoding           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>Encoding</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set client-side character encoding. 
<p>
Search the PostgreSQL documentation for "multibyte" or "character set encodings" to find out more about the available encodings, how to extend them, and how to use them. Not all server-side encodings are compatible with all client-side encodings or vice versa. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Encoding</em>&nbsp;</td><td>Name of the character set encoding to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="120b9e03dcaa9b0c3ef7026afa64d954"></a><!-- doxytag: member="pqxx::connection_base::set_variable" ref="120b9e03dcaa9b0c3ef7026afa64d954" args="(const std::string &amp;Var, const std::string &amp;Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::set_variable           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>Var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>Value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set session variable. 
<p>
Set a session variable for this connection, using the SET command. If the connection to the database is lost and recovered, the last-set value will be restored automatically. See the PostgreSQL documentation for a list of variables that can be set and their permissible values. If a <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> is currently in progress, aborting that <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> will normally discard the newly set value. Known exceptions are <a class="el" href="a00055.html">nontransaction</a> (which doesn't start a real backend <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>) and PostgreSQL versions prior to 7.3. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>Do not mix the set_variable interface with manual setting of variables by executing the corresponding SQL commands, and do not get or set variables while a <a class="el" href="a00100.html" title="Base class for streaming data to/from database tables.">tablestream</a> or <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> is active on the same connection. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Var</em>&nbsp;</td><td>Variable to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>Value vor Var to assume: an identifier, a quoted string, or a number. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00218.html#l00471">is_open()</a>.</p>

</div>
</div><p>
<a class="anchor" name="908a2ffdf56d8259492e9f3894e24f65"></a><!-- doxytag: member="pqxx::connection_base::get_variable" ref="908a2ffdf56d8259492e9f3894e24f65" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string pqxx::connection_base::get_variable           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>Var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read session variable. 
<p>
Will try to read the value locally, from the list of variables set with the set_variable function. If that fails, the database is queried. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>Do not mix the set_variable interface with manual setting of variables by executing the corresponding SQL commands, and do not get or set variables while a <a class="el" href="a00100.html" title="Base class for streaming data to/from database tables.">tablestream</a> or <a class="el" href="a00062.html" title="Processes several queries in FIFO manner, optimized for high throughput.">pipeline</a> is active on the same connection. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a839a066c0289a12f664e29c9dbafd38"></a><!-- doxytag: member="pqxx::connection_base::get_notifs" ref="a839a066c0289a12f664e29c9dbafd38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::get_notifs           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check for pending notifications and take appropriate action. 
<p>
All notifications found pending at call time are processed by finding any matching listeners and invoking those. If no listeners matched the notification string, none are invoked but the notification is considered processed.<p>
Exceptions thrown by client-registered listeners handlers are reported using the connection's message <a class="el" href="a00057.html" title="Base class for user-definable error/warning message processor.">noticer</a>, but the exceptions themselves are not passed on outside this function.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of notifications processed </dd></dl>

<p>References <a class="el" href="a00218.html#l00471">is_open()</a>, and <a class="el" href="a00218.html#l00514">process_notice()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l01580">await_notification()</a>, and <a class="el" href="a00257.html#l00325">pqxx::transaction_base::Begin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b5c24029bda3198d826d24757e49c746"></a><!-- doxytag: member="pqxx::connection_base::await_notification" ref="b5c24029bda3198d826d24757e49c746" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::await_notification           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for a notification to come in. 
<p>
The wait may also be terminated by other events, such as the connection to the backend failing. Any pending or received notifications are processed as part of the call.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of notifications processed </dd></dl>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>, <a class="el" href="a00218.html#l00731">get_notifs()</a>, and <a class="el" href="a00218.html#l01562">wait_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a9e66faad88a94857c0749b9bbc5d352"></a><!-- doxytag: member="pqxx::connection_base::await_notification" ref="a9e66faad88a94857c0749b9bbc5d352" args="(long seconds, long microseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::await_notification           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>microseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for a notification to come in, or for given timeout to pass. 
<p>
The wait may also be terminated by other events, such as the connection to the backend failing. Any pending or received notifications are processed as part of the call.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of notifications processed </dd></dl>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>, <a class="el" href="a00218.html#l00731">get_notifs()</a>, and <a class="el" href="a00218.html#l01562">wait_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d2b9e50c9ebfab7c86a091cd939e1e6c"></a><!-- doxytag: member="pqxx::connection_base::prepare" ref="d2b9e50c9ebfab7c86a091cd939e1e6c" args="(const std::string &amp;name, const std::string &amp;definition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">pqxx::prepare::declaration</a> pqxx::connection_base::prepare           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>definition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define a prepared statement. 
<p>
To declare parameters to this statement, add them by calling the function invocation operator (<code>operator()</code>) on the returned object. See prepare::param_declaration and <a class="el" href="a00189.html#c17c76a56c23b370ce055beef0a1eef3" title="Type of treatment of a particular parameter to a prepared statement.">prepare::param_treatment</a> for more about how to do this.<p>
The statement's definition can refer to a parameter using the parameter's positional number n in the definition. For example, the first parameter can be used as a variable "$1", the second as "$2" and so on.<p>
One might use a prepared statement as in the following example. Note the unusual syntax associated with parameter definitions and parameter passing: every new parameter is just a parenthesized expression that is simply tacked onto the end of the statement!<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">using namespace </span>pqxx;
 <span class="keywordtype">void</span> foo(<a class="code" href="a00020.html#33700cc6d830d28c3dbd48eb9b7276ab">connection_base</a> &amp;C)
 {
   C.prepare(<span class="stringliteral">"findtable"</span>,
             <span class="stringliteral">"select * from pg_tables where name=$1"</span>)
             (<span class="stringliteral">"varchar"</span>, <a class="code" href="a00189.html#c17c76a56c23b370ce055beef0a1eef30b9178cb2051d7f786e6fc811cb970f1" title="Escape special characters and add quotes.">treat_string</a>);
   <a class="code" href="a00199.html#g82685329d6fd91f5ab30772d266fe5f0" title="Bog-standard, default transaction type.">work</a> W(C);
   result R = W.prepared(<span class="stringliteral">"findtable"</span>)(<span class="stringliteral">"mytable"</span>).exec();
   <span class="keywordflow">if</span> (R.empty()) <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">"mytable not found!"</span>);
 }
</pre></div><p>
For better performance, prepared statements aren't really registered with the backend until they are first used. If this is not what you want, e.g. because you have very specific realtime requirements, you can use the <code><a class="el" href="a00020.html#32efdc645566975851bfc7d6b82d214c" title="Request that prepared statement be registered with the server.">prepare_now()</a></code> function to force immediate preparation.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>The statement may not be registered with the backend until it is actually used. So if the statement is syntactically incorrect, for example, a <a class="el" href="a00098.html">syntax_error</a> may be thrown either from here, or when you try to call the statement later, or somewhere inbetween if <a class="el" href="a00020.html#32efdc645566975851bfc7d6b82d214c" title="Request that prepared statement be registered with the server.">prepare_now()</a> is called. This is not guaranteed, and it's still possible to get a <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a> or <a class="el" href="a00088.html" title="Exception class for failed queries.">sql_error</a> here, for example.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>unique identifier to associate with new prepared statement </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>definition</em>&nbsp;</td><td>SQL statement to <a class="el" href="a00189.html" title="Dedicated namespace for helper types related to prepared statements.">prepare</a> </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00219.html#l00422">cap_prepare_unnamed_statement</a>, and <a class="el" href="a00219.html#l00449">supports()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l00875">prepare()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f2dcc39b88897fe2bc3c5742edd43645"></a><!-- doxytag: member="pqxx::connection_base::prepare" ref="f2dcc39b88897fe2bc3c5742edd43645" args="(const std::string &amp;definition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">pqxx::prepare::declaration</a> pqxx::connection_base::prepare           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>definition</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define a nameless prepared statement. 
<p>
This can be useful if you merely want to pass large binary parameters to a statement without otherwise wishing to <a class="el" href="a00189.html" title="Dedicated namespace for helper types related to prepared statements.">prepare</a> it. If you use this feature, always keep the definition and the use close together to avoid the nameless statement being redefined unexpectedly by code somewhere else. 
<p>References <a class="el" href="a00218.html#l00839">prepare()</a>.</p>

</div>
</div><p>
<a class="anchor" name="30ec51634479614b45106532e87e5dc7"></a><!-- doxytag: member="pqxx::connection_base::unprepare" ref="30ec51634479614b45106532e87e5dc7" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::unprepare           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drop prepared statement. 
<p>

</div>
</div><p>
<a class="anchor" name="32efdc645566975851bfc7d6b82d214c"></a><!-- doxytag: member="pqxx::connection_base::prepare_now" ref="32efdc645566975851bfc7d6b82d214c" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::prepare_now           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request that prepared statement be registered with the server. 
<p>
If the statement had already been fully prepared, this will do nothing.<p>
If the connection should break and be transparently restored, then the new connection will again defer registering the statement with the server. Since connections are never restored inside backend transactions, doing this once at the beginning of your <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> ensures that the statement will not be re-registered during that <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a>. In most cases, however, it's probably better not to use this and let the connection decide when and whether to register prepared statements that you've defined. 
</div>
</div><p>
<a class="anchor" name="53881917fd565daf7e66496fa74f397d"></a><!-- doxytag: member="pqxx::connection_base::perform" ref="53881917fd565daf7e66496fa74f397d" args="(const TRANSACTOR &amp;T, int Attempts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRANSACTOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::perform           </td>
          <td>(</td>
          <td class="paramtype">const TRANSACTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Attempts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> defined by a transactor-based object. 
<p>
Invokes the given <a class="el" href="a00107.html">transactor</a>, making at most Attempts attempts to perform the encapsulated code. If the code throws any exception other than <a class="el" href="a00011.html" title="Exception class for lost or failed backend connection.">broken_connection</a>, it will be aborted right away.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The <a class="el" href="a00107.html">transactor</a> to be executed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Attempts</em>&nbsp;</td><td>Maximum number of attempts to be made to execute T. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="858d1cb7c11c365faf203935a48c5f1b"></a><!-- doxytag: member="pqxx::connection_base::perform" ref="858d1cb7c11c365faf203935a48c5f1b" args="(const TRANSACTOR &amp;T)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRANSACTOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::perform           </td>
          <td>(</td>
          <td class="paramtype">const TRANSACTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>T</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> defined by a transactor-based object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The <a class="el" href="a00107.html">transactor</a> to be executed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4963aaba6da521d480c21c7ec01835cf"></a><!-- doxytag: member="pqxx::connection_base::adorn_name" ref="4963aaba6da521d480c21c7ec01835cf" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string pqxx::connection_base::adorn_name           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suffix unique number to name to make it unique within session context. 
<p>
Used internally to generate identifiers for SQL objects (such as cursors and nested transactions) based on a given human-readable base name. 
<p>References <a class="el" href="a00241.html#l01012">pqxx::to_string()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9709e4738b1bfb1dba547381749908cb"></a><!-- doxytag: member="pqxx::connection_base::cancel_query" ref="9709e4738b1bfb1dba547381749908cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::cancel_query           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to cancel the ongoing query, if any. 
<p>

</div>
</div><p>
<a class="anchor" name="1d1c129c2c5797a82f251ee9dabec77e"></a><!-- doxytag: member="pqxx::connection_base::init" ref="1d1c129c2c5797a82f251ee9dabec77e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="a00218.html#l00182">activate()</a>, <a class="el" href="a00216.html#l00057">pqxx::connectionpolicy::do_startconnect()</a>, and <a class="el" href="a00216.html#l00083">pqxx::connectionpolicy::is_ready()</a>.</p>

<p>Referenced by <a class="el" href="a00203.html#l00053">pqxx::basic_connection&lt; CONNECTPOLICY &gt;::basic_connection()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f02016af0233bed748eb1ddab9685131"></a><!-- doxytag: member="pqxx::connection_base::close" ref="f02016af0233bed748eb1ddab9685131" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="a00219.html#l00062">pqxx::internal::reactivation_avoidance_counter::clear()</a>, <a class="el" href="a00216.html#l00075">pqxx::connectionpolicy::do_disconnect()</a>, <a class="el" href="a00219.html#l00270">inhibit_reactivation()</a>, <a class="el" href="a00218.html#l00514">process_notice()</a>, and <a class="el" href="a00218.html#l00488">set_noticer()</a>.</p>

<p>Referenced by <a class="el" href="a00203.html#l00068">pqxx::basic_connection&lt; CONNECTPOLICY &gt;::~basic_connection()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f860fe4c418cfa4f573f34d73327d111"></a><!-- doxytag: member="pqxx::connection_base::wait_read" ref="f860fe4c418cfa4f573f34d73327d111" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::wait_read           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="a00218.html#l01547">pqxx::internal::wait_read()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l01580">await_notification()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b8c7dd5e54493e18d5900dd70012d062"></a><!-- doxytag: member="pqxx::connection_base::wait_read" ref="b8c7dd5e54493e18d5900dd70012d062" args="(long seconds, long microseconds) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::wait_read           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>microseconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="a00218.html#l01547">pqxx::internal::wait_read()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cfb8d53e6f105db280cd5d977c005bea"></a><!-- doxytag: member="pqxx::connection_base::wait_write" ref="cfb8d53e6f105db280cd5d977c005bea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::wait_write           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="a00218.html#l01556">pqxx::internal::wait_write()</a>.</p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="1407974cc9c548bee6d31834625c3d45"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_prepare_declaration" ref="1407974cc9c548bee6d31834625c3d45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_prepare_declaration<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c2eff365ba0aa25ebbf5f903ac3c7a54"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_prepare_invocation" ref="c2eff365ba0aa25ebbf5f903ac3c7a54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_prepare_invocation<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3c60c76e32687adce1e8c0dba0919773"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_transaction" ref="3c60c76e32687adce1e8c0dba0919773" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_transaction<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b15ff67d81467d271dc713b2584f1328"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_largeobject" ref="b15ff67d81467d271dc713b2584f1328" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_largeobject<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="518f718405d80def662f248b427f0e60"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_notify_listener" ref="518f718405d80def662f248b427f0e60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_notify_listener<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3b9c5dc16f04600aa5415e06f6ff8fa6"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_pipeline" ref="3b9c5dc16f04600aa5415e06f6ff8fa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_pipeline<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f3dfec559fe2305e57aba653abe4c8ad"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_dbtransaction" ref="f3dfec559fe2305e57aba653abe4c8ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_dbtransaction<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="84c1a28176815ab9103c7febec450755"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_sql_cursor" ref="84c1a28176815ab9103c7febec450755" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_sql_cursor<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2247d8690958f634898bbf014a7d418c"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_reactivation_avoidance_exemption" ref="2247d8690958f634898bbf014a7d418c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_reactivation_avoidance_exemption<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0e64dc314f291c6f81a948c59d94aa8a"></a><!-- doxytag: member="pqxx::connection_base::internal::gate::connection_parameterized_invocation" ref="0e64dc314f291c6f81a948c59d94aa8a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_parameterized_invocation<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00219.html">connection_base.hxx</a><li><a class="el" href="a00259.html">transactor.hxx</a><li><a class="el" href="a00128.html">connection_base.cxx</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 15 18:22:49 2010 for libpqxx by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
