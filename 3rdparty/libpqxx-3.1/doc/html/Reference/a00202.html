<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libpqxx: Transactor framework</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Transactor framework</h1>Wrapper for transactions that automatically restarts them on <a class="el" href="a00032.html" title="Run-time failure encountered by libpqxx, similar to std::runtime_error.">failure</a>.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
Some transactions may be replayed if their connection fails, until they do succeed. These can be encapsulated in a transactor-derived classes. The <a class="el" href="a00107.html">transactor</a> framework will take care of setting up a backend <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> context for the operation, and of aborting and retrying if its connection goes bad.<p>
The <a class="el" href="a00107.html">transactor</a> framework also makes it easier for you to do this safely, avoiding typical pitfalls and encouraging programmers to separate their <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> definitions (essentially, business rules implementations) from their higher-level code (application using those business rules). The former go into the transactor-based class.<p>
Pass an object of your transactor-based class to <a class="el" href="a00020.html#53881917fd565daf7e66496fa74f397d" title="Perform the transaction defined by a transactor-based object.">connection_base::perform()</a> to execute the <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> code embedded in it (see the definitions in <a class="el" href="a00129.html">pqxx/connection_base.hxx</a>).<p>
<a class="el" href="a00020.html#53881917fd565daf7e66496fa74f397d" title="Perform the transaction defined by a transactor-based object.">connection_base::perform()</a> is actually a template, specializing itself to any <a class="el" href="a00107.html">transactor</a> type you pass to it. This means you will have to pass it a reference of your object's ultimate static type; runtime polymorphism is not allowed. Hence the absence of virtual methods in <a class="el" href="a00107.html">transactor</a>. The exact methods to be called at runtime *must* be resolved at compile time.<p>
Your transactor-derived class must define a copy constructor. This will be used to create a "clean" copy of your <a class="el" href="a00107.html">transactor</a> for every attempt that perform() makes to run it. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 15 18:22:46 2010 for libpqxx by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
