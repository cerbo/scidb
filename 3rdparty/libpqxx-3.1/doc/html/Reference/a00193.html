<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libpqxx: Prepared statements</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Prepared statements</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
Prepared statements are SQL queries that you define once and then invoke as many times as you like, typically with varying parameters. It's basically a function that you can define ad hoc.<p>
If you have an SQL statement that you're going to execute many times in quick succession, it may be more efficient to <a class="el" href="a00189.html" title="Dedicated namespace for helper types related to prepared statements.">prepare</a> it once and reuse it. This saves the database backend the effort of parsing complex SQL and figuring out an efficient execution plan. Another nice side effect is that you don't need to worry about escaping parameters.<p>
You create a prepared statement by preparing it on the connection, passing an identifier and its SQL text. The identifier is the name by which the prepared statement will be known; it should consist of letters, digits, and underscores only and start with a letter. The name is case-sensitive.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> prepare_my_statement(<a class="code" href="a00020.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> &amp;c)
 {
   c.<a class="code" href="a00020.html#d2b9e50c9ebfab7c86a091cd939e1e6c" title="Define a prepared statement.">prepare</a>(<span class="stringliteral">"my_statement"</span>, <span class="stringliteral">"SELECT * FROM Employee WHERE name = 'Xavier'"</span>);
 }
</pre></div><p>
Once you've done this, you'll be able to call <code>my_statement</code> from any <a class="el" href="a00104.html" title="Standard back-end transaction, templatized on isolation level.">transaction</a> you execute on the same connection. Note that this uses a member function called <code>"prepared"</code>; the definition used a member function called <code>"prepare"</code>.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="a00076.html" title="Query or command result set.">pqxx::result</a> execute_my_statement(<a class="code" href="a00105.html">pqxx::transaction_base</a> &amp;t)
 {
   <span class="keywordflow">return</span> t.<a class="code" href="a00105.html#1357ac4f6330284129c91882a169276d" title="Execute prepared statement.">prepared</a>(<span class="stringliteral">"my_statement"</span>).exec();
 }
</pre></div><p>
Did I mention that you can pass parameters to prepared statements? You define those along with the statement. The query text uses $<code>1</code>, <code>$2</code> etc. as placeholders for the parameters in the SQL text. Since your C++ compiler doesn't know how many parameters you're going to define, the syntax that lets you do this is a bit strange:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> prepare_find(<a class="code" href="a00020.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> &amp;c)
 {
   <span class="comment">// Prepare a statement called "find" that looks for employees with a given</span>
   <span class="comment">// name (parameter 1) whose salary exceeds a given number (parameter 2).</span>
   <span class="keyword">const</span> std::string sql =
     <span class="stringliteral">"SELECT * FROM Employee WHERE name = $1 AND salary &gt; $2"</span>;
 
   c.<a class="code" href="a00020.html#d2b9e50c9ebfab7c86a091cd939e1e6c" title="Define a prepared statement.">prepare</a>(<span class="stringliteral">"find"</span>, sql)(<span class="stringliteral">"varchar"</span>, <a class="code" href="a00189.html#c17c76a56c23b370ce055beef0a1eef30b9178cb2051d7f786e6fc811cb970f1" title="Escape special characters and add quotes.">pqxx::prepare::treat_string</a>)(<span class="stringliteral">"integer"</span>);
 }
</pre></div><p>
The first parameter is defined as having SQL type <code>varchar</code>; and libpqxx is to treat it as a string. This last point matters if prepared-statement support is missing in the current backend version or the underlying C library, and libpqxx needs to emulate the prepared statement. See <a class="el" href="a00189.html#c17c76a56c23b370ce055beef0a1eef3" title="Type of treatment of a particular parameter to a prepared statement.">pqxx::prepare::param_treatment</a> for the list of ways parameters may need to be treated. This detail will go away in the future.<p>
The second parameter is an integer, with default treatment by libpqxx.<p>
When invoking the prepared statement, you pass parameter values using the same syntax.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="a00076.html" title="Query or command result set.">pqxx::result</a> execute_find(
   <a class="code" href="a00105.html">pqxx::transaction_base</a> &amp;t, std::string name, <span class="keywordtype">int</span> min_salary)
 {
   <span class="keywordflow">return</span> t.<a class="code" href="a00105.html#1357ac4f6330284129c91882a169276d" title="Execute prepared statement.">prepared</a>(<span class="stringliteral">"find"</span>)(name)(min_salary).exec();
 }
</pre></div><p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>There are cases where prepared statements are actually slower than plain SQL. Sometimes the backend can produce a better execution plan when it knows the parameter values. For example, say you've got a web application and you're querying for users with status "inactive" who have email addresses in a given domain name X. If X is a very popular provider, the best way to plan the query may be to list the inactive users first and then filter for the email addresses you're looking for. But in other cases, it may be much faster to find matching email addresses first and then see which of their owners are "inactive." A prepared statement must be planned to fit either case, but a direct query can be optimized based on table statistics, partial indexes, etc. </dd></dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Feb 15 18:22:46 2010 for libpqxx by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
