<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libpqxx: Prepared statements</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpqxx
   &#160;<span id="projectnumber">3.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00196.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Prepared statements</div>  </div>
</div><!--header-->
<div class="contents">
<p>Prepared statements are SQL queries that you define once and then invoke as many times as you like, typically with varying parameters. It's basically a function that you can define ad hoc.</p>
<p>If you have an SQL statement that you're going to execute many times in quick succession, it may be more efficient to prepare it once and reuse it. This saves the database backend the effort of parsing complex SQL and figuring out an efficient execution plan. Another nice side effect is that you don't need to worry about escaping parameters.</p>
<p>You create a prepared statement by preparing it on the connection, passing an identifier and its SQL text. The identifier is the name by which the prepared statement will be known; it should consist of letters, digits, and underscores only and start with a letter. The name is case-sensitive.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> prepare_my_statement(<a class="code" href="a00023.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> &amp;c)</div>
<div class="line">{</div>
<div class="line">  c.<a class="code" href="a00023.html#ad2b9e50c9ebfab7c86a091cd939e1e6c" title="Define a prepared statement.">prepare</a>(<span class="stringliteral">&quot;my_statement&quot;</span>, <span class="stringliteral">&quot;SELECT * FROM Employee WHERE name = &#39;Xavier&#39;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Once you've done this, you'll be able to call <code>my_statement</code> from any transaction you execute on the same connection. Note that this uses a member function called <code>"prepared"</code>; the definition used a member function called <code>"prepare"</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="a00084.html" title="Query or command result set.">pqxx::result</a> execute_my_statement(<a class="code" href="a00107.html">pqxx::transaction_base</a> &amp;t)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> t.<a class="code" href="a00107.html#a1357ac4f6330284129c91882a169276d" title="Execute prepared statement.">prepared</a>(<span class="stringliteral">&quot;my_statement&quot;</span>).<a class="code" href="a00055.html#af937364fbb9bf4cead8c646220a4507d" title="Execute!">exec</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Did I mention that you can pass parameters to prepared statements? You define those along with the statement. The query text uses $<code>1</code>, <code>$2</code> etc. as placeholders for the parameters in the SQL text. Since your C++ compiler doesn't know how many parameters you're going to define, the syntax that lets you do this is a bit strange:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> prepare_find(<a class="code" href="a00023.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> &amp;c)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Prepare a statement called &quot;find&quot; that looks for employees with a given</span></div>
<div class="line">  <span class="comment">// name (parameter 1) whose salary exceeds a given number (parameter 2).</span></div>
<div class="line">  <span class="keyword">const</span> std::string sql =</div>
<div class="line">    <span class="stringliteral">&quot;SELECT * FROM Employee WHERE name = $1 AND salary &gt; $2&quot;</span>;</div>
<div class="line"></div>
<div class="line">  c.<a class="code" href="a00023.html#ad2b9e50c9ebfab7c86a091cd939e1e6c" title="Define a prepared statement.">prepare</a>(<span class="stringliteral">&quot;find&quot;</span>, sql)(<span class="stringliteral">&quot;varchar&quot;</span>, <a class="code" href="a00192.html#ac17c76a56c23b370ce055beef0a1eef3a0b9178cb2051d7f786e6fc811cb970f1" title="Escape special characters and add quotes.">pqxx::prepare::treat_string</a>)(<span class="stringliteral">&quot;integer&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The first parameter is defined as having SQL type <code>varchar</code>; and libpqxx is to treat it as a string. This last point matters if prepared-statement support is missing in the current backend version or the underlying C library, and libpqxx needs to emulate the prepared statement. See <a class="el" href="a00192.html#ac17c76a56c23b370ce055beef0a1eef3" title="Type of treatment of a particular parameter to a prepared statement.">pqxx::prepare::param_treatment</a> for the list of ways parameters may need to be treated. This detail will go away in the future.</p>
<p>The second parameter is an integer, with default treatment by libpqxx.</p>
<p>When invoking the prepared statement, you pass parameter values using the same syntax.</p>
<div class="fragment"><div class="line"><a class="code" href="a00084.html" title="Query or command result set.">pqxx::result</a> execute_find(</div>
<div class="line">  <a class="code" href="a00107.html">pqxx::transaction_base</a> &amp;t, std::string name, <span class="keywordtype">int</span> min_salary)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> t.<a class="code" href="a00107.html#a1357ac4f6330284129c91882a169276d" title="Execute prepared statement.">prepared</a>(<span class="stringliteral">&quot;find&quot;</span>)(name)(min_salary).<a class="code" href="a00055.html#af937364fbb9bf4cead8c646220a4507d" title="Execute!">exec</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>There are cases where prepared statements are actually slower than plain SQL. Sometimes the backend can produce a better execution plan when it knows the parameter values. For example, say you've got a web application and you're querying for users with status "inactive" who have email addresses in a given domain name X. If X is a very popular provider, the best way to plan the query may be to list the inactive users first and then filter for the email addresses you're looking for. But in other cases, it may be much faster to find matching email addresses first and then see which of their owners are "inactive." A prepared statement must be planned to fit either case, but a direct query can be optimized based on table statistics, partial indexes, etc. </dd></dl>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 20 2013 12:57:21 for libpqxx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
