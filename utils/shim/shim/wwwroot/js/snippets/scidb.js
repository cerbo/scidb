ace.define("ace/snippets/scidb",["require","exports","module"], function(require, exports, module) {
"use strict";

exports.snippetText = "snippet uniq \n\
	uniq ( ${1:input_array },${2:['chunk_size=CHUNK_SIZE'] } )\n\
	---- doc ----<div class='doc'> uniq (input_array [,'chunk_size=CHUNK_SIZE'] )<br><br> <b>Summary</b><br><br>   The input array must have a single attribute of any type and a single<br>   dimension. The data in the input array must be sorted and dense. The<br>   operator is built to accept the output produced by sort() with a single<br>   attribute.  The output array shall have the same attribute with the<br>   dimension i starting at 0 and chunk size of 1 million.  An optional<br>   chunk_size parameter may be used to set a different output chunk size.<br><br>   Data is compared using a simple bitwise comparison of underlying<br>   memory. Null values are discarded from the output.<br><br> <b>Input</b><br><br> array &lt;single_attribute: INPUT_ATTRIBUTE_TYPE&gt; [single_dimension= *]<br> <br><b>Output</b><br><br> array<br> &lt;<br>   single_attribute: INPUT_ATTRIBUTE_TYPE<br> &gt;<br> [<br>   i = 0:*,CHUNK_SIZE,0<br> ]<br> See PhysicalUniq.cpp for a description of the algorithm.<br> <b>Examples</b><br><pre><br>    uniq (sorted_array)<br>    store ( uniq ( sort ( project (big_array, string_attribute) ), 'chuk_size=100000'), string_attribute_index )<br><br></pre>\n\
snippet cast \n\
	cast ( ${1:srcArray},${2:schemaArray | schema } )\n\
	---- doc ----<div class='doc'>   cast( srcArray, schemaArray | schema )<br><br> <b>Summary</b><br><br>   Produces a result array with data from srcArray but with the provided<br>   schema.  There are three primary purposes:<br><br>	- To change names of attributes or dimensions.<br>	- To change types of attributes<br>	- To change a non-integer dimension to an integer dimension.<br>	- To change a nulls-disallowed attribute to a nulls-allowed<br>	attribute.<br><br> <b>Input</b><br><br>	- srcArray: a source array.<br>	- schemaArray | schema: an array or a schema, from which attrs<br>	and dims will be used by the output array.<br><br> <br><b>Output array</b><br><br> &lt;<br>   attrs<br> &gt;<br> [<br>   dims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - cast(A, &lt;q:uint64, s:double&gt;[y=2011:2012,2,0, i=1:3,3,0]) &lt;q:uint64, s:double&gt; [y, i] =<br>       y,    i,      q,       s<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br><br></pre>\n\
snippet variable_window \n\
	variable_window ( ${1:srcArray},${2:dim},${3:leftEdge},${4:rightEdge },${5:[ AGGREGATE_CALL]+ } )\n\
	---- doc ----<div class='doc'>   variable_window( srcArray, dim, leftEdge, rightEdge {, AGGREGATE_CALL}+<br>   )<br><br><br> AGGREGATE_CALL := AGGREGATE_FUNC(inputAttr) [as resultName]<br> AGGREGATE_FUNC := approxdc | avg | count | max | min | sum | stdev |<br> var | some_use_defined_aggregate_function<br><br> <b>Summary</b><br><br>   Produces a result array with the same dimensions as the source array,<br>   where each cell stores some aggregates calculated over a 1D window<br>   covering the current cell.  The window has fixed number of non-empty<br>   elements. For instance, when rightEdge is 1, the window extends to<br>   the right-hand side however number of coordinatesthat are needed,<br>   to cover the next larger non-empty cell.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- dim: along which dimension is the window defined.<br>	- leftEdge: how many cells to the left of the current cell are<br>	included in the window.<br><br>	- rightEdge: how many cells to the right of the current cell<br>	are included in the window.<br><br>	- 1 or more aggregate calls.<br>     Each aggregate call has an AGGREGATE_FUNC, an inputAttr and a<br>     resultName.  The default resultName is inputAttr followed by '_'<br>     and then AGGREGATE_FUNC.<br><br> <br><b>Output array</b><br><br> &lt;<br>   the list of aggregate attribute names. Each is source attribute name<br>   followed by \"_\" then the aggregate function name.<br><br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- For a dense array, this is a special case of window().<br>	- For the aggregate function approxdc(), the attribute name<br>	is currently non-conventional. It is xxx_ApproxDC instead of<br>	xxx_approxdc. Should change.<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - variable_window(A, item, 1, 0, sum(quantity)) &lt;quantity_sum: uint64&gt; [year, item] =<br>      year, item, quantity_sum<br>      2011,  2,      7<br>      2011,  3,      13<br>      2012,  1,      5<br>      2012,  2,      14<br>      2012,  3,      17<br><br></pre>\n\
snippet unpack \n\
	unpack ( ${1:srcArray},${2:newDim } )\n\
	---- doc ----<div class='doc'>   unpack( srcArray, newDim )<br><br> <b>Summary</b><br><br>   Unpacks a multi-dimensional array into a single-dimensional array,<br>   creating new attributes to represent the dimensions in the source<br>   array.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- newDim: the name of the dimension in the result 1D array.<br> <br><b>Output array</b><br><br> &lt;<br>   srcDims (as attributes in the output), followed by srcAttrs<br> &gt;<br> [<br>   newDim: start=0, end=#logical cells in srcArray less 1, chunk<br>   interval=the chunk interval of the last dimension in srcDims<br><br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet redimension \n\
	redimension ( ${1:srcArray},${2:schemaArray | schema },${3:isStrict=true | },${4:[ AGGREGATE_CALL] } )\n\
	---- doc ----<div class='doc'>   redimension( srcArray, schemaArray | schema , isStrict=true | {,<br>   AGGREGATE_CALL}* )<br><br><br> AGGREGATE_CALL := AGGREGATE_FUNC(inputAttr) [as resultName]<br> AGGREGATE_FUNC := approxdc | avg | count | max | min | sum | stdev |<br> var | some_use_defined_aggregate_function<br><br> <b>Summary</b><br><br>   Produces a array using some or all of the variables of a source array,<br>   potentially changing some or all of those variables from dimensions<br>   to attributes or vice versa, and optionally calculating aggregates<br>   to be included in the new array.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- schemaArray | schema: an array or schema from which outputAttrs<br>	and outputDims can be acquired.<br>     All the dimensions in outputDims must exist either in srcAttrs or in<br>     srcDims, with one exception. One new dimension called the synthetic<br>     dimension is allowed. All the attributes in outputAttrs, which is<br>     not the result of an aggregate, must exist either in srcAttrs or<br>     in srcDims.<br><br>	- isStrict if true, enables the data integrity checks such as<br>	for data collisions and out-of-order input chunks, defualt=false.<br>     In case of aggregates, isStrict requires that the aggreates be<br>     specified for all source array attributes which are also attributes<br>     in the new array.	In case of synthetic dimension, isStrict has<br>     no effect.<br><br>	- 0 or more aggregate calls.<br>     Each aggregate call has an AGGREGATE_FUNC, an inputAttr and<br>     a resultName.  The default resultName is inputAttr followed by<br>     '_' and then AGGREGATE_FUNC.  The resultNames must already exist<br>     in outputAttrs.<br><br> <br><b>Output array</b><br><br> &lt;<br>   outputAttrs<br> &gt;<br> [<br>   outputDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- The synthetic dimension cannot co-exist with aggregates. That<br>	is, if there exists at least one aggregate call, the synthetic<br>	dimension must not exist.<br><br>	- When multiple values are \"redimensioned\" into the same cell<br>	in the output array, the collision handling depends on the schema:<br><br>	(a) If there exists a synthetic dimension, all the values are<br>	retained in a vector along the synthetic dimension.<br><br>	(b) Otherwise, for an aggregate attribute, the aggregate result<br>	of the values is stored.<br><br>	(c) Otherwise, an arbitrary value is picked and the rest are<br>	discarded.<br><br>	- Current redimension() does not support Non-integer dimensions<br>	or data larger than memory.<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet slice \n\
	slice ( ${1:srcArray },${2:[ dim},${3:dimValue] } )\n\
	---- doc ----<div class='doc'>   slice( srcArray {, dim, dimValue}* )<br><br> <b>Summary</b><br><br>   Produces a 'slice' of the source array, by holding zero or more<br>   dimension values constant.  The result array does not include the<br>   dimensions that are used for slicing.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- dim: one of the dimensions to be used for slicing.<br>	- dimValue: the constant value in the dimension to slice.<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims less the list of slicing dims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet cancel \n\
	cancel ( ${1:queryId } )\n\
	---- doc ----<div class='doc'>   cancel( queryId )<br><br> <b>Summary</b><br><br>   Cancels a query by ID.<br><br> <b>Input</b><br><br>	- queryId: the query ID that can be obtained from the SciDB log<br>	or via the list() command.<br><br> <br><b>Output array</b><br><br>   n/a<br><br> <b>Errors</b><br><br>	- SCIDB_SE_QPROC::SCIDB_LE_QUERY_NOT_FOUND: if queryId does<br>	not exist.<br><br> <b>Notes</b><br><br>	- This operator is designed for internal use.<br>/class LogicalCancel: public LogicalOperator<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet cumulate \n\
	cumulate ( ${1:inputArray },${2:[ AGGREGATE_ALL]+ },${3:[ aggrDim] } )\n\
	---- doc ----<div class='doc'>  cumulate ( inputArray {, AGGREGATE_ALL}+ [, aggrDim] )<br><br> AGGREGATE_CALL := AGGREGATE_FUNC ( inputAttribute ) [ AS aliasName ]<br> AGGREGATE_FUNC := approxdc | avg | count | max | min | sum | stdev |<br> var | some_use_defined_aggregate_function<br><br> <b>Summary</b><br><br>   Calculates a running aggregate over some aggregate along some<br>   fluxVector (a single dimension of the inputArray).<br><br> <b>Input</b><br><br>	- inputArray: an input array<br>	- 1 or more aggregate calls.<br>	- aggrDim: the name of a dimension along with aggregates are<br>	computed.<br>      Default is the first dimension.<br><br> <br><b>Output array</b><br><br> &lt;<br>  The aggregate calls' aliasNames with corresponding types.<br> &gt;<br> [<br>   The output array has the same size and shape as the inputArray.<br> ]<br>     input:		   cumulate(input, sum(v) as sum_v, count(*)<br>     as cnt, I)<br>    +-I-&gt;<br>   J|	  00   01   02	 03		 00	  01	   02	    03<br>    V	+----+----+----+----+	     +--------+--------+--------+--------+<br>    00	| 01 |	  | 02 |    |	00   | (1, 1) |        | (3, 2) |	 |<br>	+----+----+----+----+	     +--------+--------+--------+--------+<br>    01	|    | 03 |    | 04 |	01   |	      | (3, 1) |	| (7, 2) |<br>	+----+----+----+----+	     +--------+--------+--------+--------+<br>    02	| 05 |	  | 06 |    |	02   | (5, 1) |        | (11, 2)|	 |<br>	+----+----+----+----+	     +--------+--------+--------+--------+<br>    03	|    | 07 |    | 08 |	03   |	      | (7, 1) |	| (15, 2)|<br>	+----+----+----+----+	     +--------+--------+--------+--------+<br>    @endverbatim<br><br>  <b>Errors</b><br><br>  <b>Notes</b><br><br>	- For now, cumulate does NOT handle input array that have<br>	overlaps.<br>  <b>Examples</b><br><pre><br>  @verbatim<br><br></pre>\n\
snippet regrid \n\
	regrid ( ${1:srcArray },${2:[ blockSize]+ },${3:[ AGGREGATE_CALL]+ },${4:[ chunkSize] } )\n\
	---- doc ----<div class='doc'>   regrid( srcArray {, blockSize}+ {, AGGREGATE_CALL}+ {, chunkSize}* )<br><br> AGGREGATE_CALL := AGGREGATE_FUNC(inputAttr) [as resultName]<br> AGGREGATE_FUNC := approxdc | avg | count | max | min | sum | stdev |<br> var | some_use_defined_aggregate_function<br><br> <b>Summary</b><br><br>   Partitions the cells in the source array into blocks (with the given<br>   blockSize in each dimension), and for each block, calculates the<br>   required aggregates.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- A list of blockSizes, one for each dimension.<br>	- 1 or more aggregate calls.<br>     Each aggregate call has an AGGREGATE_FUNC, an inputAttr and a<br>     resultName.  The default resultName is inputAttr followed by '_'<br>     and then AGGREGATE_FUNC.  For instance, the default resultName<br>     for sum(sales) is 'sales_sum'.  The count aggregate may take *<br>     as the input attribute, meaning to count all the items in the<br>     group including null items.  The default resultName for count(*)<br>     is 'count'.<br><br>	- 0 or numDims chunk sizes.<br>     If no chunk size is given, the chunk sizes from the input dims will<br>     be used.  If at least one chunk size is given, the number of chunk<br>     sizes must be equal to the number of dimensions, and the specified<br>     chunk sizes will be used.<br><br> <br><b>Output array</b><br><br> &lt;<br>   the aggregate calls' resultNames<br> &gt;<br> [<br>   srcDims, with reduced size in every dimension, and the provided chunk<br>   sizes if any.<br><br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- Regrid does not allow a block to span chunks. So for every<br>	dimension, the chunk interval needs to be a multiple of the<br>	block size.<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet aggregate \n\
	aggregate ( ${1:srcArray },${2:[ AGGREGATE_CALL]+ },${3:[ groupbyDim] },${4:[ chunkSize] } )\n\
	---- doc ----<div class='doc'>   aggregate( srcArray {, AGGREGATE_CALL}+ {, groupbyDim}* {,<br>   chunkSize}* )<br><br><br> AGGREGATE_CALL := AGGREGATE_FUNC(inputAttr) [as resultName]<br> AGGREGATE_FUNC := approxdc | avg | count | max | min | sum | stdev |<br> var | some_use_defined_aggregate_function<br><br> <b>Summary</b><br><br>   Calculates aggregates over groups of values in an array, given the<br>   aggregate types and attributes to aggregate on.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- 1 or more aggregate calls.<br>     Each aggregate call has an AGGREGATE_FUNC, an inputAttr and a<br>     resultName.  The default resultName is inputAttr followed by '_'<br>     and then AGGREGATE_FUNC.  For instance, the default resultName<br>     for sum(sales) is 'sales_sum'.  The count aggregate may take *<br>     as the input attribute, meaning to count all the items in the<br>     group including null items.  The default resultName for count(*)<br>     is 'count'.<br><br>	- 0 or more dimensions that together determines the grouping<br>	criteria.<br><br>	- 0 or numGroupbyDims chunk sizes.<br>     If no chunk size is given, the groupby dims will inherit chunk<br>     sizes from the input array.  If at least one chunk size is given,<br>     the number of chunk sizes must be equal to the number of groupby<br>     dimensions, and the groupby dimensions will use the specified<br>     chunk sizes.<br><br> <br><b>Output array</b><br><br> &lt;<br>   The aggregate calls' resultNames.<br> &gt;<br> [<br>   The list of groupbyDims if provided (with the specified chunk sizes<br>   if provided),<br><br>   or<br>   'i' if no groupbyDim is provided.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- All the aggregate functions ignore null values, except count(*).<br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - aggregate(A, count(*), max(quantity), sum(sales), year) &lt;count: uint64, quantity_max: uint64, sales_sum: double&gt; [year] =<br>      year, count, quantity_max, sales_sum<br>      2011,   2,      7,           51.62<br>      2012,   3,      9,          108.97<br><br></pre>\n\
snippet window \n\
	window ( ${1:srcArray },${2:[ leftEdge},${3:rightEdge]+ },${4:[ AGGREGATE_CALL]+ },${5:[ METHOD ] } )\n\
	---- doc ----<div class='doc'>   window( srcArray {, leftEdge, rightEdge}+ {, AGGREGATE_CALL}+ [,<br>   METHOD ] )<br><br><br> AGGREGATE_CALL := AGGREGATE_FUNC(inputAttr) [as resultName]<br> AGGREGATE_FUNC := approxdc | avg | count | max | min | sum | stdev |<br> var | some_use_defined_aggregate_function<br><br> METHOD := 'materialize' | 'probe'<br> <b>Summary</b><br><br>   Produces a result array with the same size and dimensions as the<br>   source array, where each ouput cell stores some aggregate calculated<br>   over a window around the corresponding cell in the source array. A<br>   pair of window specification values (leftEdge, rightEdge) must exist<br>   for every dimension in the source and output array.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- leftEdge: how many cells to the left of the current cell<br>	(in one dimension) are included in the window.<br><br>	- rightEdge: how many cells to the right of the current cell<br>	(in one dimension) are included in the window.<br><br>	- 1 or more aggregate calls.<br>     Each aggregate call has an AGGREGATE_FUNC, an inputAttr and a<br>     resultName.  The default resultName is inputAttr followed by '_'<br>     and then AGGREGATE_FUNC.  For instance, the default resultName<br>     for sum(sales) is 'sales_sum'.  The count aggregate may take *<br>     as the input attribute, meaning to count all the items in the<br>     group including null items.  The default resultName for count(*)<br>     is 'count'.<br><br>	- An optional final argument that specifies how the operator is<br>	to perform<br>     its calculation. At the moment, we support two internal algorithms:<br>     \"materialize\" (which materializes an entire source chunk before<br>     computing the output windows) and \"probe\" (which probes the source<br>     array for the data in each window). In general, materializing the<br>     input is a more efficient strategy, but when we're using thin(...) in<br>     conjunction with window(...), we're often better off using probes,<br>     rather than materilization. This is a decision that the optimizer<br>     needs to make.<br><br> <br><b>Output array</b><br><br> &lt;<br>   the aggregate calls' resultNames<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - window(A, 0, 0, 1, 0, sum(quantity)) &lt;quantity_sum: uint64&gt; [year, item] =<br>      year, item, quantity_sum<br>      2011,  2,      7<br>      2011,  3,      13<br>      2012,  1,      5<br>      2012,  2,      14<br>      2012,  3,      17<br><br></pre>\n\
snippet store \n\
	store ( ${1:srcArray},${2:outputArray } )\n\
	---- doc ----<div class='doc'>   store( srcArray, outputArray )<br><br> <b>Summary</b><br><br>   Stores an array to the database. Each execution of store() causes a<br>   new version of the array to be created.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDim.<br>	- outputArray: an existing array in the database, with the same<br>	schema as srcArray.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet testsplitarray \n\
	testsplitarray ( ${1:schemaArray } )\n\
	---- doc ----<div class='doc'>   testsplitarray( schemaArray )<br><br> <b>Summary</b><br><br>   Produces an output array with easily-generated values using SplitArray.<br>   This makes it easy to test whether SplitArray works across all<br>   combinations of size & chunksize (it did not at one time).<br><br> <b>Input</b><br><br>	- schemaArray: a 2D array of doubles which is used only to<br>	specify the schema of the output<br><br> <br><b>Output array</b><br><br>	- a schemaArray-sized array of doubles, where each value is the<br>	row-major ordering of the cells, beginning with 0<br><br> <b>Errors</b><br><br>   SYSTEM_EXCEPTION(SCIDB_SE_INTERNAL, SCIDB_LE_ILLEGAL_OPERATION)<br><br> <b>Notes</b><br><br>   This is a test operator, designed for testing an operator-under-test.<br>   It is not a goal to subject the test operator to the same level of<br>   testing as production operators.  This would be a mis-application<br>   of energy.  However, it is appropriate to improve this operator in<br>   order to more completely test the operator-under-test.<br><br>class LogicalSplitArrayTest : public  LogicalOperator { public:<br>    LogicalSplitArrayTest(const std::string& logicalName, const<br>    std::string& alias):<br>	LogicalOperator(logicalName, alias)<br>    {<br>	ADD_PARAM_INPUT();<br>    }<br><br>    ArrayDesc inferSchema(std::vector&lt; ArrayDesc&gt; schemas,<br>    std::shared_ptr&lt; Query&gt; query) {<br>	if(schemas.size() &gt; 1) {<br>	    throw SYSTEM_EXCEPTION(SCIDB_SE_INTERNAL,<br>	    SCIDB_LE_ILLEGAL_OPERATION) &lt;&lt; \"LogicalSplitArrayTest:<br>	    no input schema.\";<br>	} ArrayDesc& schema = schemas[0]; // hereafter reduced to<br>	schemas[0] only<br><br>	if(schema.getAttributes(true).size() != 1)<br>	    throw SYSTEM_EXCEPTION(SCIDB_SE_INTERNAL,<br>	    SCIDB_LE_ILLEGAL_OPERATION)<br>		      &lt;&lt; \"LogicalSplitArrayTest: no attribute in<br>		      input schema (must have a first attribute of<br>		      type double).\";<br><br>	if(schema.getAttributes()[0].getType() != TID_DOUBLE)<br>	    throw SYSTEM_EXCEPTION(SCIDB_SE_INTERNAL,<br>	    SCIDB_LE_ILLEGAL_OPERATION)<br>		      &lt;&lt; \"LogicalSplitArrayTest: first attribute must<br>		      be of type double\";<br><br>	if(schema.getDimensions().size() != 2)<br>	    throw SYSTEM_EXCEPTION(SCIDB_SE_INTERNAL,<br>	    SCIDB_LE_ILLEGAL_OPERATION)<br>		      &lt;&lt; \"LogicalSplitArrayTest: input schema must have<br>		      2 dimensions\";<br><br>	DimensionDesc d0 = schema.getDimensions()[0]; // hereafter reduced<br>	to two dims only DimensionDesc d1 = schema.getDimensions()[1];<br>	if (d0.isMaxStar() || d1.isMaxStar()) {<br>	    throw SYSTEM_EXCEPTION(SCIDB_SE_INTERNAL,<br>	    SCIDB_LE_ILLEGAL_OPERATION)<br>		      &lt;&lt; \"LogicalSplitArrayTest: input schema must be<br>		      bounded in both dimensions\";<br>	}<br><br>	Attributes outAtts; AttributeDesc resultAttr(AttributeID(0),<br>	\"v\",  TID_DOUBLE, 0, 0); outAtts.push_back(resultAttr);<br><br>	Dimensions outDims;<br>	outDims.push_back(DimensionDesc(d0.getBaseName(),<br>	d0.getNamesAndAliases(),<br>					d0.getStartMin(),<br>					d0.getCurrStart(),<br>					d0.getCurrEnd(), d0.getEndMax(),<br>					d0.getChunkInterval(), 0));<br>	outDims.push_back(DimensionDesc(d1.getBaseName(),<br>	d1.getNamesAndAliases(),<br>					d1.getStartMin(),<br>					d1.getCurrStart(),<br>					d1.getCurrEnd(), d1.getEndMax(),<br>					d1.getChunkInterval(), 0));<br><br>	return ArrayDesc(\"Splitarraytest\", outAtts, outDims,<br>	defaultPartitioning());<br>    }<br>};<br><br>DECLARE_LOGICAL_OPERATOR_FACTORY(LogicalSplitArrayTest, \"_splitarraytest\")<br>} //namespace scidb<br> <b>Examples</b><br><pre><br>    testsplitarray(&lt;double val&gt; [col=0:&lt;ncol&gt;:0:0, row=0:&lt;nrow&gt;:0:0])<br><br></pre>\n\
snippet consume \n\
	consume ( ${1:array },${2:[ numAttrsToScanAtOnce] } )\n\
	---- doc ----<div class='doc'>   consume( array [, numAttrsToScanAtOnce] )<br><br> <b>Summary</b><br><br>   Accesses each cell of an input array, if possible, by extracting tiles<br>   and iterating over tiles.  numAttrsToScanAtOnce determines the number<br>   of attributes to scan as a group.  Setting this value to \"1\" will<br>   result in a \"vertical\" scan---all chunks of the current attribute will<br>   be scanned before moving on to the next attribute.  Setting this value<br>   to the number of attributes will result in a \"horizontal\" scan---chunk<br>   i of every attribute will be scanned before moving on to chunk i+1<br><br> <b>Input</b><br><br>	- array: the array to consume<br>	- numAttrsToScanAtOnce: optional \"stride\" of the scan, default<br>	is 1<br><br> <br><b>Output array (an empty array)</b><br><br> &lt;<br> &gt;<br> [<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet _explain_physical \n\
	_explain_physical ( ${1:query },${2:language = 'aql' } )\n\
	---- doc ----<div class='doc'>   _explain_physical( query , language = 'aql' )<br><br> <b>Summary</b><br><br>   Produces a single-element array containing the physical query plan.<br><br> <b>Input</b><br><br>	- query: a query string.<br>	- language: the language string; either 'aql' or 'afl'; default is<br>	'aql'<br><br> <br><b>Output array</b><br><br> &lt;<br>   physical_plan: string<br> &gt;<br> [<br>   No: start=end=0, chunk interval=1.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- For internal usage.<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet dimensions \n\
	dimensions ( ${1:srcArray } )\n\
	---- doc ----<div class='doc'>   dimensions( srcArray )<br><br> <b>Summary</b><br><br>   List the dimensions of the source array.<br><br> <b>Input</b><br><br>	- srcArray: a source array.<br> <br><b>Output array</b><br><br> &lt;<br>   name: string<br>   start: int64,<br>   length: uint64<br>   chunk_interval: int32<br>   chunk_overlap: int32<br>   low: int64<br>   high: int64<br>   type: string<br> &gt;<br> [<br>   No: start=0, end=#dimensions less 1, chunk interval=#dimensions.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet versions \n\
	versions ( ${1:srcArray } )\n\
	---- doc ----<div class='doc'>   versions( srcArray )<br><br> <b>Summary</b><br><br>   Lists all versions of an array in the database.<br><br> <b>Input</b><br><br>	- srcArray: a source array.<br> <br><b>Output array</b><br><br> &lt;<br>   version_id<br>   timestamp: a string describing the creation time of the version<br> &gt;<br> [<br>   VersionNo: start=1, end=#versions, chunk interval=#versions<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet show \n\
	show ( ${1:schemaArray | schema | queryString },${2:[ 'aql' | 'afl'] } )\n\
	---- doc ----<div class='doc'>   show( schemaArray | schema | queryString [, 'aql' | 'afl'] )<br><br> <b>Summary</b><br><br>   Shows the schema of an array.<br><br> <b>Input</b><br><br>	- schemaArray | schema | queryString: an array where the schema<br>	is used, the schema itself or arbitrary query string<br><br>	- 'aql' | 'afl': Language specifier for query string<br> <br><b>Output array</b><br><br> &lt;<br>   schema: string<br> &gt;<br> [<br>   i: start=end=0, chunk interval=1<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet build \n\
	build ( ${1:schemaArray | schema},${2:expression},${3:mustBeConstant = false } )\n\
	---- doc ----<div class='doc'>   build( schemaArray | schema, expression, mustBeConstant = false )<br><br> <b>Summary</b><br><br>   Produces a result array according to a given schema, and populates<br>   values based on the given expression. The schema must have a single<br>   attribute.<br><br> <b>Input</b><br><br>	- schemaArray | schema: an array or a schema, from which attrs<br>	and dims will be used by the output array.<br><br>	- expression: the expression which is used to compute values<br>	for the output array.<br><br>	- mustBeConstant: whether the expression must be a constant.<br> <br><b>Output array</b><br><br> &lt;<br>   attrs<br> &gt;<br> [<br>   dims<br> ]<br> <b>Errors</b><br><br>	- SCIDB_SE_INFER_SCHEMA::SCIDB_LE_OP_BUILD_ERROR2, if the source<br>	array has more than one attribute.<br><br> <b>Notes</b><br><br>	- The build operator can only take as input bounded dimensions.<br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64&gt; [year, item] =<br>      year, item, quantity<br>      2011,  2,      7<br>      2011,  3,      6<br>      2012,  1,      5<br>      2012,  2,      9<br>      2012,  3,      8<br>   - build(A, 0) &lt;quantity: uint64&gt; [year, item] =<br>      year, item, quantity<br>      2011,  1,      0<br>      2011,  2,      0<br>      2011,  3,      0<br>      2012,  1,      0<br>      2012,  2,      0<br>      2012,  3,      0<br>     Note that the cell (2011, 1), which was empty in the source array, is populated.<br><br></pre>\n\
snippet diskinfo \n\
	diskinfo (  )\n\
	---- doc ----<div class='doc'>   diskinfo()<br><br> <b>Summary</b><br><br>   Checks disk usage.<br><br> <b>Input</b><br><br>   n/a<br><br> <br><b>Output array</b><br><br> &lt;<br>   used: uint64<br>   available: uint64<br>   clusterSize: uint64<br>   nFreeClusters: uint64<br>   nSegments: uint64<br> &gt;<br> [<br>   Instance: start=0, end=#instances less 1, chunk interval=1.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- For internal usage.<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet reduce_distro \n\
	reduce_distro ( ${1:replicatedArray},${2:partitioningSchema } )\n\
	---- doc ----<div class='doc'>   reduce_distro( replicatedArray, partitioningSchema )<br><br> <b>Summary</b><br><br>   Makes a replicated array appear as if it has the required<br>   partitioningSchema.<br><br> <b>Input</b><br><br>	- replicatedArray: an source array which is replicated across<br>	all the instances.<br><br>	- partitioningSchema: the desired partitioning schema.<br> <br><b>Output array</b><br><br> &lt;<br>   same attributes as in replicatedArray<br> &gt;<br> [<br>   same dimensions as in replicatedArray<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet reshape \n\
	reshape ( ${1:srcArray},${2:schema } )\n\
	---- doc ----<div class='doc'>   reshape( srcArray, schema )<br><br> <b>Summary</b><br><br>   Produces a result array containing the same cells as, but a different<br>   shape from, the source array.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- schema: the desired schema, with the same attributes as<br>	srcAttrs, but with different size and/or number of dimensions.<br>     The restriction is that the product of the dimension sizes is equal<br>     to the number of cells in srcArray.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   dimensions from the provided schema<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet list \n\
	list ( ${1:what='arrays'},${2:showSystem=false } )\n\
	---- doc ----<div class='doc'>   list( what='arrays', showSystem=false )<br><br> <b>Summary</b><br><br>   Produces a result array and loads data from a given file, and<br>   optionally stores to shadowArray.  The available things to list<br>   include:<br><br>	- aggregates: show all the aggregate operators.<br>	- arrays: show all the arrays.<br>	- chunk descriptors: show all the chunk descriptors.<br>	- chunk map: show the chunk map.<br>	- functions: show all the functions.<br>	- instances: show all SciDB instances.<br>	- libraries: show all the libraries that are loaded in the<br>	current SciDB session.<br><br>	- operators: show all the operators and the libraries in which<br>	they reside.<br><br>	- types: show all the datatypes that SciDB supports.<br>	- queries: show all the active queries.<br>	- datastores: show information about each datastore<br>	- counters: (undocumented) dump info from performance counters<br> <b>Input</b><br><br>	- what: what to list.<br>	- showSystem: whether to show systems information.<br> <br><b>Output array</b><br><br> &lt;<br>   The list of attributes depends on the input.<br> &gt;<br> [<br>   No: sequence number<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet apply \n\
	apply ( ${1:srcArray },${2:[ newAttr},${3:expression]+} )\n\
	---- doc ----<div class='doc'>   apply(srcArray {, newAttr, expression}+)<br><br> <b>Summary</b><br><br>   Produces a result array with new attributes and computes values<br>   for them.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- 1 or more pairs of a new attribute and the expression to<br>	compute the values for the attribute.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br>   the list of newAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>	- SCIDB_SE_INFER_SCHEMA::SCIDB_LE_DUPLICATE_ATTRIBUTE_NAME,<br>	if a new attribute has the same name as an existing attribute.<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - apply(A, unitprice, sales/quantity) &lt;quantity: uint64, sales: double, unitprice: double&gt; [year, item] =<br>      year, item, quantity, sales, unitprice<br>      2011,  2,      7,     31.64,   4.52<br>      2011,  3,      6,     19.98,   3.33<br>      2012,  1,      5,     41.65,   8.33<br>      2012,  2,      9,     40.68,   4.52<br>      2012,  3,      8,     26.64,   3.33<br><br></pre>\n\
snippet save \n\
	save ( ${1:srcArray},${2:file},${3:instanceId = -2},${4:format = 'store' } )\n\
	---- doc ----<div class='doc'>   save( srcArray, file, instanceId = -2, format = 'store' )<br><br> <b>Summary</b><br><br>   Saves the data in an array to a file.<br><br> <b>Input</b><br><br>	- srcArray: the source array to save from.<br>	- file: the file to save to.<br>	- instanceId: positive number means an instance ID on which file<br>	will be saved.<br><br>	-1 means to save file on every instance. -2 - on coordinator.<br>	- format: @c ArrayWriter format in which file will be stored<br> See ArrayWriter::isSupportedFormat<br> <br><b>Output array</b><br><br>   the srcArray is returned<br><br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet save \n\
	save ( ${1:srcArray},${2:file},${3:instanceId = -2},${4:format = 'store' } )\n\
	---- doc ----<div class='doc'>   save( srcArray, file, instanceId = -2, format = 'store' )<br><br> <b>Summary</b><br><br>   Saves the data in an array to a file.<br><br> <b>Input</b><br><br>	- srcArray: the source array to save from.<br>	- file: the file to save to.<br>	- instanceId: positive number means an instance ID on which file<br>	will be saved.<br><br>	-1 means to save file on every instance. -2 - on coordinator.<br>	- format: @c ArrayWriter format in which file will be stored<br> See ArrayWriter::isSupportedFormat<br> <br><b>Output array</b><br><br>   the srcArray is returned<br><br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet merge \n\
	merge ( ${1:leftArray},${2:rightArray } )\n\
	---- doc ----<div class='doc'>   merge( leftArray, rightArray )<br><br> <b>Summary</b><br><br>   Combines elements from the input arrays the following way: for each<br>   cell in the two inputs, if the cell of leftArray is not empty, the<br>   attributes from that cell are selected and placed in the output array;<br>   otherwise, the attributes from the corresponding cell in rightArray<br>   are taken.  The two arrays should have the same attribute list,<br>   number of dimensions, and dimension start index.  If the dimensions<br>   are not the same size, the output array uses the larger of the two.<br><br> <b>Input</b><br><br>	- leftArray: the left-hand-side array.<br>	- rightArray: the right-hand-side array.<br> <br><b>Output array</b><br><br> &lt;<br>   leftAttrs: which is equivalent to rightAttrs.<br> &gt;<br> [<br>   max(leftDims, rightDims): for each dim, use the larger of leftDim<br>   and rightDim.<br><br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet project \n\
	project ( ${1:srcArray },${2:[ selectedAttr]+ } )\n\
	---- doc ----<div class='doc'>   project( srcArray {, selectedAttr}+ )<br><br> <b>Summary</b><br><br>   Produces a result array that includes some attributes of the source<br>   array.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- a list of at least one selectedAttrs from the source array.<br> <br><b>Output array</b><br><br> &lt;<br>   selectedAttrs: the selected attributes<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet transpose \n\
	transpose ( ${1:srcArray } )\n\
	---- doc ----<div class='doc'>   transpose( srcArray )<br><br> <b>Summary</b><br><br>   Produces an array with the same data in srcArray but with the list<br>   of dimensions reversd.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs.<br> &gt;<br> [<br>   reverse order of srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet load_library \n\
	load_library ( ${1:library } )\n\
	---- doc ----<div class='doc'>   load_library( library )<br><br> <b>Summary</b><br><br>   Loads a SciDB plugin.<br><br> <b>Input</b><br><br>	- library: the name of the library to load.<br> <br><b>Output array</b><br><br>	- NULL<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- A library may be unloaded using unload_library()<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet index_lookup \n\
	index_lookup ( ${1:input_array},${2:index_array},${3:input_array.attribute_name },${4:[output_attribute_name] },${5:['memory_limit=MEMORY_LIMIT']} )\n\
	---- doc ----<div class='doc'> index_lookup (input_array, index_array, input_array.attribute_name<br> [,output_attribute_name] [,'memory_limit=MEMORY_LIMIT'])<br><br> <b>Summary</b><br><br>   The input_array may have any attributes or dimensions. The index_array<br>   must have a single dimension and a single non-nullable attribute. The<br>   index array data must be sorted, unique values with no empty cells<br>   between them (though it does not necessarily need to be populated to<br>   the upper bound). The third argument must correctly refer to one of<br>   the attributes of the input array - the looked-up attribute. This<br>   attribute must have the same datatype as the only attribute of the<br>   index array. The comparison \"&lt;\" function must be registered in SciDB<br>   for this datatype.<br><br>   The operator will create a new attribute, named<br>   input_attribute_name_index by default, or using the provided name,<br>   which will be the new last non-empty-tag attribute in the output<br>   array. The output attribute will be of type int64 nullable and will<br>   contain the respective coordinate of the corresponding input_attribute<br>   in index_array. If the corresponding input_attribute is null, or if<br>   no value for input_attribute exists in the index_array, the output<br>   attribute at that position shall be set to null. The output attribute<br>   shall be returned along all the input attributes in a fashion similar<br>   to the apply() operator.<br><br>   The operator uses some memory to cache a part of the index_array for<br>   fast lookup of values. By default, the size of this cache is limited<br>   to MEM_ARRAY_THRESHOLD. Note this is in addition to the memory already<br>   consumed by cached MemArrays as the operator is running. If a larger<br>   or smaller limit is desired, the 'memory_limit' parameter may be<br>   used. It is provided in units of mebibytes and must be at least 1.<br><br>   The operator may be further optimized to reduce memory footprint,<br>   optimized with a more clever data distribution pattern and/or extended<br>   to use multiple index arrays at the same time.<br><br> <b>Input</b><br><br> input_array &lt;..., input_attribute: type,... &gt; [*]<br> index_array &lt;index_attribute: type not null&gt; [dimension=0:any,any,any]<br> input_attribute                --the name of the input attribute<br> [output_attribute_name]        --the name for the output attribute<br> if desired<br><br> ['memory_limit=MEMORY_LIMIT']  --the memory limit to use MB)<br> <br><b>Output array</b><br><br> &lt;<br>   ...<br>   input_attribute_name:type<br>   ...<br>   output_attribute:int64 null  --default name is<br>   input_attribute_name+\"_index\", i.e. \"stock_symbol_index\".<br><br> &gt;<br> [ * ]<br> See PhysicalIndexLookup.cpp for a description of the algorithm.<br> The code assumes familiarity with the concepts described in<br> hello_instances nad instance_stats. Consider reading those operators<br> first.  See LogicalHelloInstances.cpp See LogicalInstanceStats.cpp<br> Author apoliakov@paradigm4.com<br> <b>Examples</b><br><pre><br>    index_lookup(stock_trades, stock_symbols, stock_trades.ticker)<br>    index_lookup(stock_trades, stock_symbols, stock_trades.ticker, ticker_id, 'memory_limit=1024')<br><br></pre>\n\
snippet filter \n\
	filter ( ${1:srcArray},${2:expression } )\n\
	---- doc ----<div class='doc'>   filter( srcArray, expression )<br><br> <b>Summary</b><br><br>   The filter operator returns an array the with the same schema as the<br>   input array. The result is identical to the input except that those<br>   cells for which the expression evaluates either false or null are<br>   marked as being empty.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- expression: an expression which takes a cell in the source<br>	array as input and evaluates to either True or False.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet help \n\
	help ( ${1:operator } )\n\
	---- doc ----<div class='doc'>   help( operator )<br><br> <b>Summary</b><br><br>   Produces a single-element array containing the help information for<br>   an operator.<br><br> <b>Input</b><br><br>	- operator: the name of an operator.<br> <br><b>Output array</b><br><br> &lt;<br>   help: string<br> &gt;<br> [<br>   i: start=end=0, chunk interval=1.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet test_sg \n\
	test_sg ( ${1:srcArray},${2:partitionSchema},${3:instanceId=-1},${4:sgMode},${5:isStrict=false},${6:offsetVector=null} )\n\
	---- doc ----<div class='doc'>   test_sg( srcArray, partitionSchema, instanceId=-1, sgMode,<br>   isStrict=false, offsetVector=null)<br><br><br> <b>Summary</b><br><br>   SCATTER/GATHER distributes array chunks over the instances of<br>   a cluster.  The result array is returned.<br><br> <b>Input</b><br><br>	- srcArray: the source array, with srcAttrs and srcDims.<br>	- partitionSchema:<br>     0 = psReplication,<br>     1 = psHashPartitioned,<br>     2 = psLocalInstance,<br>     3 = psByRow,<br>     4 = psByCol,<br>     5 = psUndefined.<br>	- instanceId:<br>	-2 = to coordinator (same with 0),<br>	-1 = all instances participate,<br>     0..#instances-1 = to a particular instance.<br>	- sgMode:<br>     'serial'-all attributes are redistributed in order;<br>     'parallel' - all attributes are redistributed concurrently;<br>     ''='parallel'<br>	- isStrict if true, enables the data integrity checks such as<br>	for data collisions and out-of-order input chunks, defualt=false.<br><br>	- offsetVector: a vector of #dimensions values.<br>     To calculate which instance a chunk belongs, the chunkPos is<br>     augmented with the offset vector before calculation.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet sg \n\
	sg ( ${1:srcArray},${2:partitionSchema},${3:instanceId=-1},${4:outputArray=''},${5:isStrict=false},${6:offsetVector=null} )\n\
	---- doc ----<div class='doc'>   sg( srcArray, partitionSchema, instanceId=-1, outputArray=\"\",<br>   isStrict=false, offsetVector=null)<br><br><br> <b>Summary</b><br><br>   SCATTER/GATHER distributes array chunks over the instances of<br>   a cluster.  The result array is returned.  It is the only operator<br>   that uses the network manager.  Typically this operator is inserted<br>   by the optimizer into the physical plan.<br><br> <b>Input</b><br><br>	- srcArray: the source array, with srcAttrs and srcDims.<br>	- partitionSchema:<br>     0 = psReplication,<br>     1 = psHashPartitioned,<br>     2 = psLocalInstance,<br>     3 = psByRow,<br>     4 = psByCol,<br>     5 = psUndefined.<br>	- instanceId:<br>	-2 = to coordinator (same with 0),<br>	-1 = all instances participate,<br>     0..#instances-1 = to a particular instance.<br>     [TO-DO: The usage of instanceId, in calculating which instance a<br>     chunk should go to, requires further documentation.]<br><br>	- outputArray: if not empty, the result will be stored into<br>	this array<br><br>	- isStrict if true, enables the data integrity checks such as<br>	for data collisions and out-of-order input chunks, defualt=false.<br><br>	- offsetVector: a vector of #dimensions values.<br>     To calculate which instance a chunk belongs, the chunkPos is<br>     augmented with the offset vector before calculation.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet unload_library \n\
	unload_library ( ${1:library } )\n\
	---- doc ----<div class='doc'>   unload_library( library )<br><br> <b>Summary</b><br><br>   Unloads a SciDB plugin.<br><br> <b>Input</b><br><br>	- library: the name of the library to unload.<br> <br><b>Output array</b><br><br>	- NULL<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- This operator is the reverse of load_library().<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet materialize \n\
	materialize ( ${1:srcArray},${2:format } )\n\
	---- doc ----<div class='doc'>   materialize( srcArray, format )<br><br> <b>Summary</b><br><br>   Produces a materialized version of an source array.<br><br> <b>Input</b><br><br>	- srcArray: the sourcce array with srcDims and srcAttrs.<br>	- format: uint32, the materialize format.<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet _explain_logical \n\
	_explain_logical ( ${1:query },${2:language = 'aql' } )\n\
	---- doc ----<div class='doc'>   _explain_logical( query , language = 'aql' )<br><br> <b>Summary</b><br><br>   Produces a single-element array containing the logical query plan.<br><br> <b>Input</b><br><br>	- query: a query string.<br>	- language: the language string; either 'aql' or 'afl'; default is<br>	'aql'<br><br> <br><b>Output array</b><br><br> &lt;<br>   logical_plan: string<br> &gt;<br> [<br>   No: start=end=0, chunk interval=1.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- For internal usage.<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet cross_join \n\
	cross_join ( ${1:leftArray},${2:rightArray },${3:[ attrLeft},${4:attrRight] } )\n\
	---- doc ----<div class='doc'>   cross_join( leftArray, rightArray {, attrLeft, attrRight}* )<br><br> <b>Summary</b><br><br>   Calculates the cross product of two arrays, with 0 or more equality<br>   conditions on the dimensions.  Assume p pairs of equality conditions<br>   exist. The result is an (m+n-p) dimensional array.  From the<br>   coordinates of each cell in the result array, a single cell in<br>   leftArray and a single cell in rightArray can be located.  The cell<br>   in the result array contains the concatenation of the attributes from<br>   the two source cells.  If a pair of join dimensions have different<br>   lengths, the result array uses the smaller of the two.<br><br> <b>Input</b><br><br>	- leftArray: the left-side source array with leftAttrs and<br>	leftDims.<br><br>	- rightArray: the right-side source array with rightAttrs and<br>	rightDims.<br><br>	- 0 or more pairs of an attribute from leftArray and an attribute<br>	from rightArray.<br><br> <br><b>Output array</b><br><br> &lt;<br>   leftAttrs + rightAttrs<br> &gt;<br> [<br>   leftDims + (rightDims - leftDims)<br> ]<br>	- Given array B &lt;v:uint64&gt; [k] =<br> k,  v<br> 1,  10<br> 2,  20<br> 3,  30<br> 4,  40<br> 5,  50<br>	- cross_join(A, B, item, k) &lt;quantity: uint64, sales:double,<br>	v:uint64&gt; [year, item] =<br><br> year, item, quantity, sales,  v<br> 2011,	2,	7,     31.64,  20<br> 2011,	3,	6,     19.98,  30<br> 2012,	1,	5,     41.65,  10<br> 2012,	2,	9,     40.68,  20<br> 2012,	3,	8,     26.64,  30<br> <b>Errors</b><br><br>	- SCIDB_SE_OPERATOR::SCIDB_LE_OP_CROSSJOIN_ERROR2: if the number<br>	of input dimensions is not even.<br><br>	- SCIDB_SE_INFER_SCHEMA::SCIDB_LE_ARRAYS_NOT_CONFORMANT: if<br>	any join dimension is not an integer dimension, or if a pair of<br>	join dimensions<br>     do not have the same start, chunk interval, or overlap.<br><br> <b>Notes</b><br><br>	- Joining non-integer dimensions does not work.<br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br><br></pre>\n\
snippet join \n\
	join ( ${1:leftArray},${2:rightArray } )\n\
	---- doc ----<div class='doc'>   join( leftArray, rightArray )<br><br> <b>Summary</b><br><br>   Combines the attributes of two arrays at matching dimension values.<br>   The two arrays must have the same dimension start coordinates, the<br>   same chunk size, and the same chunk overlap.  The join result has the<br>   same dimension names as the first input.  The cell in the result array<br>   contains the concatenation of the attributes from the two source cells.<br>   If a pair of join dimensions have different lengths, the result array<br>   uses the smaller of the two.<br><br> <b>Input</b><br><br>	- leftArray: the left-side source array with leftAttrs and<br>	leftDims.<br><br>	- rightArray: the right-side source array with rightAttrs and<br>	rightDims.<br><br> <br><b>Output array</b><br><br> &lt;<br>   leftAttrs + rightAttrs: in case an attribute in rightAttrs conflicts<br>   with an attribute in leftAttrs, '_2' will be appended.<br><br> &gt;<br> [<br>   leftDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- join() is a special case of cross_join() with all pairs of<br>	dimensions given.<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet load_module \n\
	load_module ( ${1:module } )\n\
	---- doc ----<div class='doc'>   load_module( module )<br><br> <b>Summary</b><br><br>   Loads a SciDB module.<br><br> <b>Input</b><br><br>	- module: the path name of the module file to load.<br> <br><b>Output array</b><br><br>	- NULL<br> <b>Errors</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet repart \n\
	repart ( ${1:srcArray},${2:schema } )\n\
	---- doc ----<div class='doc'>   repart( srcArray, schema )<br><br> <b>Summary</b><br><br>   Produces a result array similar to the source array, but with different<br>   chunk sizes, different chunk overlaps, or both.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- schema: the desired schema.<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   dimensions from the desired schema<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet subarray \n\
	subarray ( ${1:srcArray },${2:[ lowCoord]+ },${3:[ highCoord]+ } )\n\
	---- doc ----<div class='doc'>   subarray( srcArray {, lowCoord}+ {, highCoord}+ )<br><br> <b>Summary</b><br><br>   Produces a result array from a specified, contiguous region of a<br>   source array.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- the low coordinates<br>	- the high coordinates<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims, where the range of every dimension is reduced to<br>   [0..windowSize-1]<br><br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- Almost the same as between(). The only difference is that the<br>	dimensions are \"cropped\".<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - subarray(A, 2011, 1, 2012, 2) &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>       0,     1,      7,     31.64<br>       1,     0,      5,     41.65<br>       1,     1,      9,     40.68<br><br></pre>\n\
snippet bernoulli \n\
	bernoulli ( ${1:srcArray},${2:probability },${3:[ seed] } )\n\
	---- doc ----<div class='doc'>   bernoulli( srcArray, probability [, seed] )<br><br> <b>Summary</b><br><br>   Evaluates whether to include a cell in the result array by generating<br>   a random number and checks if it is less than probability.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- probability: the probability threshold, in [0..1]<br>	- an optional seed for the random number generator.<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - bernoulli(A, 0.5, 100) &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  3,      8,     26.64<br><br></pre>\n\
snippet old_sort \n\
	old_sort ( ${1:srcArray },${2:[ attr [asc | desc]] },${3:[ chunkSize]? } )\n\
	---- doc ----<div class='doc'>   old_sort( srcArray {, attr [asc | desc]}* {, chunkSize}? )<br><br> <b>Summary</b><br><br>   Produces a 1D array by sorting the non-empty cells of a source array.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDim.<br>	- attr: the list of attributes to sort by. If no attribute is<br>	provided, the first attribute will be used.<br><br>	- asc | desc: whether ascending or descending order of the<br>	attribute should be used. The default is asc.<br><br>	- chunkSize: the size of a chunk in the result array. If not<br>	provided, 1M will be used.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs: all the attributes are retained.<br> &gt;<br> [<br>   n: start=0, end=MAX_COORDINATE, chunk interval = min{defaultChunkSize,<br>   #logical cells in srcArray)<br><br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   Assuming null &lt; NaN &lt; other values<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet sort \n\
	sort ( ${1:srcArray },${2:[ attr [asc | desc]] },${3:[ chunkSize]? } )\n\
	---- doc ----<div class='doc'>   sort( srcArray {, attr [asc | desc]}* {, chunkSize}? )<br><br> <b>Summary</b><br><br>   Produces a 1D array by sorting the non-empty cells of a source array.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDim.<br>	- attr: the list of attributes to sort by. If no attribute is<br>	provided, the first attribute will be used.<br><br>	- asc | desc: whether ascending or descending order of the<br>	attribute should be used. The default is asc.<br><br>	- chunkSize: the size of a chunk in the result array. If not<br>	provided, 1M will be used.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs: all the attributes are retained.<br> &gt;<br> [<br>   n: start=0, end=CoordinateBounds::getMax(), chunk interval =<br>   min{defaultChunkSize, #logical cells in srcArray)<br><br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   Assuming null &lt; NaN &lt; other values<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet attributes \n\
	attributes ( ${1:srcArray } )\n\
	---- doc ----<div class='doc'>   attributes( srcArray )<br><br> <b>Summary</b><br><br>   Produces a 1D result array where each cell describes one attribute<br>   of the source array.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br> <br><b>Output array</b><br><br> &lt;<br>   name: string<br>   type_id: string<br>   nullable: bool<br> &gt;<br> [<br>   No: start=0, end=#attributes less 1, chunk interval=#attributes.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - attributes(A) &lt;name:string, type_id:string, nullable:bool&gt; [No] =<br>      No,   name,    type_id, nullable<br>      0, \"quantity\", \"uint64\", false<br>      1,   \"sales\",  \"double\", false<br><br></pre>\n\
snippet unfold \n\
	unfold ( ${1:array } )\n\
	---- doc ----<div class='doc'>   unfold( array )<br><br> <b>Summary</b><br><br>   Complicated input data are often loaded into table-like 1-d<br>   multi-attribute arrays. Sometimes we want to assemble uniformly-typed<br>   subsets of the array attributes into a matrix, for example to<br>   compute correlations or regressions. unfold will transform the input<br>   array into a 2-d matrix whose columns correspond to the input array<br>   attributes. The output matrix row dimension will have a chunk size<br>   equal to the input array, and column chunk size equal to the number<br>   of columns.<br><br> <b>Input</b><br><br>	- array: the array to consume<br> <br><b>Output array</b><br><br> &lt;<br> &gt;<br> [<br> ]<br> <b>Errors</b><br><br>   SCIDB_LE_ILLEGAL_OPERATION<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   unfold(apply(build(&lt;v:double&gt;[i=0:9,3,0],i),w,i+0.5))<br><br></pre>\n\
snippet xgrid \n\
	xgrid ( ${1:srcArray },${2:[ scale]+ } )\n\
	---- doc ----<div class='doc'>   xgrid( srcArray {, scale}+ )<br><br> <b>Summary</b><br><br>   Produces a result array by 'scaling up' the source array.  Within each<br>   dimension, the operator duplicates each cell a specified number of<br>   times before moving to the next cell.  A scale must be provided for<br>   every dimension.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- scale: for each dimension, a scale is provided telling how<br>	much larger the dimension should grow.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims where every dimension is expanded by a given scale<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - xgrid(A, 1, 2) &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  3,      7,     31.64<br>      2011,  4,      7,     31.64<br>      2011,  5,      6,     19.98<br>      2011,  6,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      5,     41.65<br>      2012,  3,      9,     40.68<br>      2012,  4,      9,     40.68<br>      2012,  5,      8,     26.64<br>      2012,  6,      8,     26.64<br><br></pre>\n\
snippet substitute \n\
	substitute ( ${1:srcArray},${2:substituteArray },${3:[ attr] } )\n\
	---- doc ----<div class='doc'>   substitute( srcArray, substituteArray {, attr}* )<br><br> <b>Summary</b><br><br>   Produces a result array the same as srcArray, but with null values (of<br>   selected attributes) substituted using the values in substituteArray.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims, that may<br>	contain null values.<br><br>	- substituteArray: the array from which the values may be used<br>	to substitute the null values in srcArray.<br>     It must have a single dimension which starts at 0, and a single<br>     attribute.<br><br>	- An optional list of attributes to substitute. The default is<br>	to substitute all nullable attributes.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet cross_between \n\
	cross_between ( ${1:srcArray},${2:rangesArray } )\n\
	---- doc ----<div class='doc'>   cross_between( srcArray, rangesArray )<br><br> <b>Summary</b><br><br>   Produces a result array by cutting out data in one of the rectangular<br>   ranges specified in rangesArray.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- rangesArray: an array with (|srcDims| * 2) attributes all<br>	having type int64.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- Similar to between().<br>	- The operator only works if the size of the rangesArray is<br>	very small.<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - Given array R &lt;year_low, item_low, year_high, item_high&gt;[i] =<br>      i, year_low, item_low, year_high, item_high<br>      0, 2011,      3,       2011,       3<br>      1, 2012,      1,       2012,       2<br>   - cross_between(A, R) &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br><br></pre>\n\
snippet between \n\
	between ( ${1:srcArray },${2:[ lowCoord]+ },${3:[ highCoord]+ } )\n\
	---- doc ----<div class='doc'>   between( srcArray {, lowCoord}+ {, highCoord}+ )<br><br> <b>Summary</b><br><br>   Produces a result array from a specified, contiguous region of a<br>   source array.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- the low coordinates<br>	- the high coordinates<br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- Almost the same as subarray. The only difference is that the<br>	dimensions retain the original start/end/boundaries.<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - between(A, 2011, 1, 2012, 2) &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br><br></pre>\n\
snippet avg_rank \n\
	avg_rank ( ${1:srcArray },${2:[ attr },${3:[ groupbyDim]] } )\n\
	---- doc ----<div class='doc'>   avg_rank( srcArray [, attr {, groupbyDim}*] )<br><br> <b>Summary</b><br><br>   Ranks the array elements, where each element is ranked as the<br>   average of the upper bound (UB) and lower bound (LB) rankings.  The LB<br>   ranking of an element E is the number of elements less than E, plus 1.<br>   The UB ranking of an element E is the number of elements less than<br>   or equal to E, plus 1.<br><br> <b>Input</b><br><br>	- srcArray: a source array with srcAttrs and srcDims.<br>	- 0 or 1 attribute to rank with. If no attribute is provided,<br>	the first attribute is used.<br><br>	- an optional list of groupbyDims used to group the elements,<br>	such that the rankings are calculated within each group.<br>     If no groupbyDim is provided, the whole array is treated as one<br>     group.<br><br> <br><b>Output array</b><br><br> &lt;<br>   attr: the source attribute to rank with.<br>   attr_rank: the source attribute name, followed by '_rank'.<br> &gt;<br> [<br>   srcDims<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>	- For any element with a distinct value, its UB ranking and LB<br>	ranking are equal.<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;quantity: uint64, sales:double&gt; [year, item] =<br>      year, item, quantity, sales<br>      2011,  2,      7,     31.64<br>      2011,  3,      6,     19.98<br>      2012,  1,      5,     41.65<br>      2012,  2,      9,     40.68<br>      2012,  3,      8,     26.64<br>   - avg_rank(A, sales, year) &lt;sales:double, sales_rank: uint64&gt; [year, item] =<br>      year, item, sales, sales_rank<br>      2011,  2,   31.64,    2<br>      2011,  3,   19.98,    1<br>      2012,  1,   41.65,    3<br>      2012,  2,   40.68,    2<br>      2012,  3,   26.64,    1<br><br></pre>\n\
snippet quantile \n\
	quantile ( ${1:srcArray},${2:numQuantiles },${3:[ attr },${4:[ groupbyDim]] } )\n\
	---- doc ----<div class='doc'>   quantile( srcArray, numQuantiles [, attr {, groupbyDim}*] )<br><br> <b>Summary</b><br><br>   Computes the quantiles of an array, based on the ordering of attr<br>   (within each group as specified by groupbyDim, if specified).<br>   If groupbyDim is not specified, global ordering will be performed.<br>   If attr is not specified, the first attribute will be used.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- numQuantiles: the number of quantiles.<br>	- attr: which attribute to sort on. The default is the first<br>	attribute.<br><br>	- groupbyDim: if provided, the ordering will be performed among<br>	the records in the same group.<br><br> <br><b>Output array</b><br><br> &lt;<br>   percentage: a double value from 0.0 to 1.0<br>   attr_quantile: the source attribute name followed by '_quantile'.<br> &gt;<br> [<br>   groupbyDims (if provided)<br>   quantile: start=0, end=numQuantiles, chunkInterval=numQuantiles+1<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   - Given array A &lt;v:int64&gt; [i=0:5,3,0] =<br>      i,  v<br>      0,  0<br>      1,  1<br>      2,  2<br>      3,  3<br>      4,  4<br>      5,  5<br>   - quantile(A, 2) &lt;percentage, v_quantile&gt;[quantile=0:2,3,0] =<br>      {quantile} percentage, v_quantile<br>      {0}           0,         0<br>      {1}           0.5,       2<br>      {2}           1,         5<br><br></pre>\n\
snippet rank \n\
	rank ( ${1:srcArray },${2:[ attr },${3:[ groupbyDim]] } )\n\
	---- doc ----<div class='doc'>   rank( srcArray [, attr {, groupbyDim}*] )<br><br> <b>Summary</b><br><br>   Computes the rankings of an array, based on the ordering of attr<br>   (within each group as specified by the list of groupbyDims, if<br>   provided).  If groupbyDims is not specified, global ordering will be<br>   performed.  If attr is not specified, the first attribute will be used.<br><br> <b>Input</b><br><br>	- srcArray: the source array with srcAttrs and srcDims.<br>	- attr: which attribute to sort on. The default is the first<br>	attribute.<br><br>	- groupbyDim: if provided, the ordering will be performed among<br>	the records in the same group.<br><br> <br><b>Output array</b><br><br> &lt;<br>   attr: only the specified attribute in srcAttrs is retained.<br>   attr_rank: the source attribute name followed by '_rank'.<br> &gt;<br> [<br>   srcDims: the shape does not change.<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet rename \n\
	rename ( ${1:oldArray},${2:newArray } )\n\
	---- doc ----<div class='doc'>   rename( oldArray, newArray )<br><br> <b>Summary</b><br><br>   Changes the name of an array.<br><br> <b>Input</b><br><br>	- oldArray: an existing array.<br>	- newArray: the new name of the array.<br> <br><b>Output array</b><br><br>   NULL<br><br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet setopt \n\
	setopt ( ${1:option },${2:[ newValue] } )\n\
	---- doc ----<div class='doc'>   setopt( option [, newValue] )<br><br> <b>Summary</b><br><br>   Gets/Sets a config option at runtime.<br><br> <b>Input</b><br><br>	- option: the config option.<br>	- newValue: an optional new value for the config option. If<br>	provided, the option is set. Either way, the option value(s)<br>	is returned.<br><br> <br><b>Output array</b><br><br> &lt;<br>   old: string<br>   new: string, if newValue is provided<br> &gt;<br> [<br>   No: start=0, end=#instances-1, chunk interval=1<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet scan \n\
	scan ( ${1:srcArray },${2:[ ifTrim] } )\n\
	---- doc ----<div class='doc'>   scan( srcArray [, ifTrim] )<br><br> <b>Summary</b><br><br>   Produces a result array that is equivalent to a stored array.<br><br> <b>Input</b><br><br>	- srcArray: the array to scan, with srcAttrs and srcDims.<br>	- ifTrim: whether to turn an unbounded array to a bounded<br>	array. Default value is false.<br><br> <br><b>Output array</b><br><br> &lt;<br>   srcAttrs<br> &gt;<br> [<br>   srcDims (ifTrim=false), or trimmed srcDims (ifTrim=true).<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet remove_versions \n\
	remove_versions ( ${1:targetArray},${2:oldestVersionToSave } )\n\
	---- doc ----<div class='doc'>   remove_versions( targetArray, oldestVersionToSave )<br><br> <b>Summary</b><br><br>   Removes all versions of targetArray that are older than<br>   oldestVersionToSave<br><br> <b>Input</b><br><br>	- targetArray: the array which is targeted.<br>	- oldestVersionToSave: the version, prior to which all versions<br>	will be removed.<br><br> <br><b>Output array</b><br><br>   NULL<br><br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet remove \n\
	remove ( ${1:arrayToRemove } )\n\
	---- doc ----<div class='doc'>   remove( arrayToRemove )<br><br> <b>Summary</b><br><br>   Drops an array.<br><br> <b>Input</b><br><br>	- arrayToRemove: the array to drop.<br> <br><b>Output array</b><br><br>   NULL<br><br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet insert \n\
	insert ( ${1:sourceArray},${2:targetArrayName } )\n\
	---- doc ----<div class='doc'>   insert( sourceArray, targetArrayName )<br><br> <b>Summary</b><br><br>   Inserts all data from left array into the persistent targetArray.<br>   targetArray must exist with matching dimensions and attributes.<br>   targetArray must also be mutable. The operator shall create a new<br>   version of targetArray that contains all data of the array that<br>   would have been received by merge(sourceArray, targetArrayName). In<br>   other words, new data is inserted between old data and overwrites<br>   any overlapping old values.  The resulting array is then returned.<br><br> <b>Input</b><br><br>	- sourceArray the array or query that provides inserted data<br>	- targetArrayName: the name of the persistent array inserted into<br> <br><b>Output array</b><br><br>	- the result of insertion<br>	- same schema as targetArray<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   Some might wonder - if this returns the same result<br>   as merge(sourceArray, targetArrayName), then why not use<br>   store(merge())? The answer is that 1. this runs a lot faster - it<br>   does not perform a full scan of targetArray 2. this also generates<br>   less chunk headers<br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet spgemm \n\
	spgemm ( ${1:leftArray},${2:rightArray },${3:[semiring] } )\n\
	---- doc ----<div class='doc'>   spgemm( leftArray, rightArray [,semiring] )<br><br> <b>Summary</b><br><br>   Produces a result array via matrix multiplication.  Both matrices must<br>   have a single numeric attribute.  The two matrices must have the same<br>   size of 'inner' dimension and same chunk size along that dimension.<br><br> <b>Input</b><br><br>	- leftArray: the left matrix with two dimensions: leftDim1,<br>	leftDim2<br><br>	- rightArray: the right matrix with two dimensions: rightDim1,<br>	rightDim2<br><br>	- [semiring]: optional name of a semiring to be used instead of<br>	ordinary arithmetic (+,*)<br>		 when performing the matrix multiplication. Supported<br>		 values are: \"min.+\" -- the Tropical Semiring, i.e. a+b -&gt;<br>		 min(a,b) ; a*b -&gt; a+b ;<br>			    the implicit sparse value is +inf.<br>		 \"max.+\" -- the Arctic Semiring,   i.e. a+b -&gt; max(a,b)<br>		 ; a*b -&gt; a+b ;<br>			    the implicit sparse vlaue is -inf.<br>		 This option is useful for writing graph theoretic<br>		 operations expressed and computed as linear algebra.<br>		 An introduction to the subject suitable for a computer<br>		 scientist is: Stephan Dolan, \"Fun with Semirings,<br>		 A functional perl on the abuse of linear algebra\"<br>		 [http://www.cl.cam.ac.uk/~sd601/papers/semirings.pdf]<br><br> <br><b>Output array</b><br><br> &lt;<br>   'multiply': the result attribute name<br> &gt;<br> [<br>   leftDim1<br>   rightDim2<br> ]<br> <b>Errors</b><br><br>   n/a<br><br> <b>Notes</b><br><br>   n/a<br><br> <b>Examples</b><br><pre><br>   n/a<br><br></pre>\n\
snippet upload    (GUI command)\n\
	upload( ${1:file} )\n\
	---- doc ----<div class='doc'><i>upload( file )</i>\n\
	<br>Upload a file to the SciDB server. Upload is a special command specific to this user interface, not a SciDB operator. At the moment, upload may only be used in queries generated by the 'Upload file...' menu due to JavaScript web browser security restrictions. The specified file is transferred to the shim sever by HTTP POST and then the <i>uplad(.*?)</i> function text is replaced with a temporary server-side file name string, and then the query is issued using that string.\n\
";
exports.scope = "scidb";
});
